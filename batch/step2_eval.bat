:: The following file is generated by build.bat. DO NOT EDIT. 
@echo off
SETLOCAL ENABLEEXTENSIONS ENABLEDELAYEDEXPANSION

:: While macros
set BREAK=EXIT
set WHILE=IF "%1"=="fi301kvnro2qa9vm2" (FOR /L %%? IN () DO IF
set DO=(
set END_WHILE=) ELSE %BREAK%) ELSE CMD /Q /C "%~F0" fi301kvnro2qa9vm2

:: Magic number that says we're calling a loop
IF "%1"=="fi301kvnro2qa9vm2" GOTO %2

set "NIL="
set "TRUE=t"
set "FALSE=f"

set _doublequote=^"
set _backslash=^\
set _singlequote=^'
set _backtick=^`
set _tilde=^~
set _splice_unquote=^~^@
set _with_meta=^^

GOTO :START

:ECHO
    IF NOT "!%1!"=="" echo !%1!
EXIT /B 0

:ABORT
    ECHO %~1
    GOTO :START
EXIT

:NIL?
    IF "!%~2!"=="" (
        set "%~1=!TRUE!"
    ) ELSE (
        set "%~1=!FALSE!"
    )
EXIT /B 0

:CONS
    set /a "_list_counter+=1"
    set "_list_first_!_list_counter!=!%~2!"
    set "_list_rest_!_list_counter!=!%~3!"
    set "%~1=L!_list_counter!"
EXIT /B 0

:FIRST
    set "ref=_list_first_!%~2:~1,8191!"
    set "%1=!%ref%!"
EXIT /B 0

:REST
    set "ref=_list_rest_!%~2:~1,8191!"
    set "%1=!%ref%!"
EXIT /B 0

:LIST?
    IF "!%2!"=="!NIL!" (
        set "%~1=!TRUE!"
    ) ELSE (
        IF "!%~2:~0,1!"=="L" (
            set "%~1=!TRUE!"
        ) ELSE (
            set "%~1=!FALSE!"
        )
    )
EXIT /B 0

:LIST_REVERSE
    set "%1=!NIL!"
    call :_LIST_REVERSE %1 %2
EXIT /B 0

:_LIST_REVERSE
    IF "!%2!"=="!NIL!" (
        EXIT /B 0
    )

    call :FIRST LIST_REVERSE_first %2
    call :REST LIST_REVERSE_rest %2

    call :CONS %1 LIST_REVERSE_first %1

    call :_LIST_REVERSE %1 LIST_REVERSE_rest
EXIT /B 0

:LIST_MAP
    set "LIST_MAP_list%_recursive_count%=!NIL!"
    call :_LIST_MAP LIST_MAP_list%_recursive_count% %2 %3 %4
    call :LIST_REVERSE %1 LIST_MAP_list%_recursive_count%
EXIT /B 0

:_LIST_MAP
    IF "!%2!"=="!NIL!" (
        EXIT /B 0
    )

    call :FIRST LIST_MAP_first%_recursive_count% %2
    call :REST LIST_MAP_rest%_recursive_count% %2

    call %3 LIST_MAP_mapped%_recursive_count% LIST_MAP_first%_recursive_count% %4

    call :CONS %1 LIST_MAP_mapped%_recursive_count% %1

    call :_LIST_MAP %1 LIST_MAP_rest%_recursive_count% %3 %4
EXIT /B 0


:VECTOR_NEW
    set /a "_vector_counter+=1"
    set "_vector_length_!_vector_counter!=0"
    set "%1=V!_vector_counter!"
EXIT /B 0

:VECTOR_LENGTH
    set "_length=_vector_length_!%2:~1,8191!"
    set "%1=!%_length%!"
EXIT /B 0

:VECTOR_GET
    set "_ref=_vector_!%2:~1,8191!_!%3!"
    set "%1=!%_ref%!"
EXIT /B 0

:VECTOR_PUSH
    set "_id=!%1:~1,8191!"
    set "_length=_vector_length_!_id!"
    set "_ref=_vector_!_id!_!%_length%!"
    set "%_ref%=!%2!"
    set /a "%_length%+=1"
EXIT /B 0

:VECTOR?
    IF "!%2:~0,1!"=="V" (
        set "%1=!TRUE!"
    ) ELSE (
        set "%1=!FALSE!"
    )
EXIT /B 0

:STRING_NEW
    set /a "_string_counter+=1"
    set "_length=_string_length_!_string_counter!"
    call :STRLEN %_length% %2
    set "_string_contents_!_string_counter!=!%2!"
    set "%1=S!_string_counter!"
EXIT /B 0

:STRING_LENGTH
    set "_length=_string_length_!%2:~1,8191!"
    set "%1=!%_length%!"
EXIT /B 0

:STRING_TO_STR
    set "_ref=_string_contents_!%2:~1,8191!"
    set "%1=!%_ref%!"
EXIT /B 0

:STRING?
    IF "!%2:~0,1!"=="S" (
        set "%1=!TRUE!"
    ) ELSE (
        set "%1=!FALSE!"
    )
EXIT /B 0

:ATOM_NEW
    set /a "_atom_counter+=1"
    set "_length=_atom_length_!_atom_counter!"
    call :STRLEN %_length% %2
    set "_atom_contents_!_atom_counter!=!%2!"
    set "%1=A!_atom_counter!"
EXIT /B 0

:ATOM_LENGTH
    set "_length=_atom_length_!%2:~1,8191!"
    set "%1=!%_length%!"
EXIT /B 0

:ATOM_TO_STR
    set "_ref=_atom_contents_!%2:~1,8191!"
    set "%1=!%_ref%!"
EXIT /B 0

:ATOM?
    IF "!%2:~0,1!"=="A" (
        set "%1=!TRUE!"
    ) ELSE (
        set "%1=!FALSE!"
    )
EXIT /B 0

:FUNCTION_NEW
    set /a "_function_counter+=1"
    set "_function_name_!_function_counter!=!%2!"
    set "%1=F!_function_counter!"
EXIT /B 0

:FUNCTION_TO_STR
    set "_ref=_function_name_!%2:~1,8191!"
    set "%1=!%_ref%!"
EXIT /B 0

:FUNCTION?
    IF "!%2:~0,1!"=="F" (
        set "%1=!TRUE!"
    ) ELSE (
        set "%1=!FALSE!"
    )
EXIT /B 0

:NUMBER_NEW
    set /a "_number_counter+=1"
    set "_number_value!_number_counter!=!%2!"
    set "%1=N!_number_counter!"
EXIT /B 0

:NUMBER_TO_STR
    set "_ref=_number_value!%2:~1,8191!"
    set "%1=!%_ref%!"
EXIT /B 0

:NUMBER_TO_STRING
    set "NUMBER_TO_STRING_str=_number_value!%2:~1,8191!"
    call :STRING_NEW %1 NUMBER_TO_STRING_str
EXIT /B 0

:NUMBER?
    IF "!%2:~0,1!"=="N" (
        set "%1=!TRUE!"
    ) ELSE (
        set "%1=!FALSE!"
    )
EXIT /B 0


:HASHMAP_NEW
    set /a "_hashmap_counter+=1"
    call :VECTOR_NEW _hashmap_keys!_hashmap_counter!
    call :VECTOR_NEW _hashmap_values!_hashmap_counter!
    set "%1=H!_hashmap_counter!"
EXIT /B 0

:HASHMAP_INSERT
    set "HASHMAP_INSERT_id=!%1:~1,8191!"
    call :VECTOR_PUSH _hashmap_keys!HASHMAP_INSERT_id! %2
    call :VECTOR_PUSH _hashmap_values!HASHMAP_INSERT_id! %3
EXIT /B 0

:_HASHMAP_INDEX_OF_KEY
    set "_HASHMAP_INDEX_OF_KEY_id=!%2:~1,8191!"
    set "%1=!NIL!"
    call :VECTOR_LENGTH _HASHMAP_INDEX_OF_KEY_length _hashmap_keys!_HASHMAP_INDEX_OF_KEY_id!
    set /a "_HASHMAP_INDEX_OF_KEY_length-=1"
    FOR /L %%G IN (0, 1, !_HASHMAP_INDEX_OF_KEY_length!) DO (
        set "_HASHMAP_INDEX_OF_KEY_index=%%G"
        call :VECTOR_GET _HASHMAP_INDEX_OF_KEY_key _hashmap_keys!_HASHMAP_INDEX_OF_KEY_id! _HASHMAP_INDEX_OF_KEY_index
        IF "!_HASHMAP_INDEX_OF_KEY_key!"=="!%3!" (
            set "%1=%%G"
        )
    )
EXIT /B 0

:HASHMAP_GET
    set "HASHMAP_GET_id=!%2:~1,8191!"
    call :_HASHMAP_INDEX_OF_KEY HASHMAP_GET_key_index %2 %3
    IF "!HASHMAP_GET_key_index!"=="!NIL!" (
        set "%1=!NIL!"
        EXIT /B 0
    )

    call :VECTOR_GET %1 _hashmap_values!HASHMAP_GET_id! HASHMAP_GET_key_index
EXIT /B 0

:HASHMAP_KEYS
    set "_id=!%2:~1,8191!"
    set "_ref=_hashmap_keys!_id!"
    set "%1=!%_ref%!"
EXIT /B 0

:HASHMAP?
    IF "!%2:~0,1!"=="H" (
        set "%1=!TRUE!"
    ) ELSE (
        set "%1=!FALSE!"
    )
EXIT /B 0

:SUBSTRING
    set "SUBSTRING_start=!%~3!"
    set "SUBSTRING_length=!%~4!"
    call :_SUBSTRING %~1 %~2 %SUBSTRING_start% %SUBSTRING_length%
EXIT /B 0

:_SUBSTRING
    set /a "_SUBSTRING_end=%~3+%~4-1"
    set "%~1=!%~2:~%~3,%_SUBSTRING_end%!"
EXIT /B 0

:STRING_CONTAINS_CHAR
    set "STRING_CONTAINS_CHAR_string=!%~2!"
    set "STRING_CONTAINS_CHAR_char=!%~3!"

:STRING_CONTAINS_CHAR_LOOP
    IF "!STRING_CONTAINS_CHAR_string!"=="" (
        set "%~1=!FALSE!"
    )

    IF "!STRING_CONTAINS_CHAR_string:~0,1!"=="!STRING_CONTAINS_CHAR_char!" (
        set "%~1=!TRUE!"
    ) ELSE (
        set "STRING_CONTAINS_CHAR_string=!STRING_CONTAINS_CHAR_string:~1,8191!"
        GOTO :STRING_CONTAINS_CHAR_LOOP
    )
EXIT /B 0

:STRLEN
    set "STRLEN_buffer=#!%2!"
    set "STRLEN_length=0"
    FOR %%N IN (8192 4096 2048 1024 512 256 128 64 32 16 8 4 2 1) DO (
        IF NOT "!STRLEN_buffer:~%%N,1!"=="" (
            set /a "STRLEN_length+=%%N"
            set "STRLEN_buffer=!STRLEN_buffer:~%%N!"
        )
    )
    set "%1=%STRLEN_length%"
EXIT /B 0

:READ_WHILE
    set "%1="
:READ_WHILE_LOOP
    IF "!%2!"=="" (
        EXIT /B 0
    )

    set "READ_WHILE_char=!%2:~0,1!"

    call %3 READ_WHILE_did_match READ_WHILE_char

    IF "!READ_WHILE_did_match!"=="!FALSE!" (
        EXIT /B 0
    )
    set "%1=!%1!!READ_WHILE_char!"
    set "%2=!%2:~1,8191!"
    GOTO :READ_WHILE_LOOP
EXIT /B 0

:READ_CHARACTER
    set "%1="

    IF "!%2!"=="" (
        EXIT /B 0
    )

    set "READ_CHARACTER_char=!%2:~0,1!"

    call %3 READ_CHARACTER_did_match READ_CHARACTER_char

    IF "!READ_CHARACTER_did_match!"=="!FALSE!" (
        EXIT /B 0
    )

    set "%1=!READ_CHARACTER_char!"
    set "%2=!%2:~1,8191!"
EXIT /B 0

:IS_COMMA_OR_SPACE
    set "%1=!FALSE!"
    IF "!%2!"=="," (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2!"==" " (set "%1=!TRUE!" & EXIT /B 0)
EXIT /B 0

:IS_SPECIAL_CHARACTER
    set "%1=!FALSE!"
    IF "!%2!"=="[" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2!"=="]" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2!"=="{" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2!"=="}" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2!"=="(" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2!"==")" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2!"=="'" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2!"=="`" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2!"=="~" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2!"=="^" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2!"=="@" (set "%1=!TRUE!" & EXIT /B 0)
EXIT /B 0

:IS_NOT_DOUBLEQUOTE_OR_BACKSLASH
    set "%1=!TRUE!"
    IF "!%2!"=="!_doublequote!" (set "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="!_backslash!" (set "%1=!FALSE!" & EXIT /B 0)
EXIT /B 0

:IS_ATOM_CHARACTER
    set "%1=!TRUE!"
    IF "!%2!"=="[" (set "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="]" (set "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="{" (set "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="}" (set "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="(" (set "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"==")" (set "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="'" (set "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="`" (set "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="~" (set "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="^" (set "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="@" (set "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="," (set "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"==" " (set "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"==";" (set "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="!_doublequote!" (set "%1=!FALSE!" & EXIT /B 0)
EXIT /B 0

:READ_STRING
    IF "!%2!"=="" (
        set "%1="
        EXIT /B 0
    )
    call :STRLEN READ_STRING_length %3
    set "READ_STRING_match=!%2:~0,%READ_STRING_length%!"
    IF "!READ_STRING_match!"=="!%3!" (
        set "%1=!READ_STRING_match!"
        set "%2=!%2:~%READ_STRING_length%!"
    ) ELSE (
        set "%1="
    )
EXIT /B 0

:READ_DOUBLEQUOTED_STRING
    set "%1="

    :: If there is a double-quote, read a quoted string
    IF "!%2:~0,1!"=="!_doublequote!" (
:READ_DOUBLEQUOTED_STRING_CONTINUE
        IF "!%2!"=="" (
            EXIT /B 0
        )

        set "%1=!%1!!%2:~0,1!"
        set "%2=!%2:~1,8191!"

        call :READ_WHILE READ_DOUBLEQUOTED_STRING_match %2 :IS_NOT_DOUBLEQUOTE_OR_BACKSLASH
        set "%1=!%1!!READ_DOUBLEQUOTED_STRING_match!"

        IF "!%2!"=="" (
            EXIT /B 0
        )

        set "READ_DOUBLEQUOTED_STRING_terminator=!%2:~0,1!"
        set "%2=!%2:~1,8191!"
        set "%1=!%1!!READ_DOUBLEQUOTED_STRING_terminator!"

        :: If the last character was a back-slash, we continue reading the string.
        IF "!READ_DOUBLEQUOTED_STRING_terminator!"=="!_backslash!" (
            GOTO :READ_DOUBLEQUOTED_STRING_CONTINUE
        )
    )
EXIT /B 0

:SKIP_COMMENT
    :: If we encounter a comment, skip the rest by emptying the buffer
    IF "!%1:~0,1!"==";" (
        set "%1="
    )
EXIT /B 0

:TOKENIZER
    :: We put the input string into a buffer for reading
    set "TOKENIZER_buffer=!%2!"
    call :VECTOR_NEW TOKENIZER_list
    set "TOKENIZER_@=~@"

:TOKENIZER_LOOP
    call :READ_WHILE TOKENIZER_token TOKENIZER_buffer :IS_COMMA_OR_SPACE
    IF NOT "!TOKENIZER_token!"=="" (
        :: Whitespace and commas are ignored
        GOTO :TOKENIZER_LOOP
    )

    call :READ_STRING TOKENIZER_token TOKENIZER_buffer TOKENIZER_@
    IF NOT "!TOKENIZER_token!"=="" (
        call :VECTOR_PUSH TOKENIZER_list TOKENIZER_token
        GOTO :TOKENIZER_LOOP
    )

    call :READ_CHARACTER TOKENIZER_token TOKENIZER_buffer :IS_SPECIAL_CHARACTER
    IF NOT "!TOKENIZER_token!"=="" (
        call :VECTOR_PUSH TOKENIZER_list TOKENIZER_token
        GOTO :TOKENIZER_LOOP
    )

    call :READ_DOUBLEQUOTED_STRING TOKENIZER_token TOKENIZER_buffer
    IF NOT "!TOKENIZER_token!"=="" (
        call :VECTOR_PUSH TOKENIZER_list TOKENIZER_token
        GOTO :TOKENIZER_LOOP
    )

    call :SKIP_COMMENT TOKENIZER_buffer

    call :READ_WHILE TOKENIZER_token TOKENIZER_buffer :IS_ATOM_CHARACTER
    IF NOT "!TOKENIZER_token!"=="" (
        call :VECTOR_PUSH TOKENIZER_list TOKENIZER_token
        GOTO :TOKENIZER_LOOP
    )

    set "%1=!TOKENIZER_list!"
EXIT /B 0

:READ_LIST
    set /a "%3+=1"
    set "%1=!NIL!"
    call :VECTOR_LENGTH READ_LIST_length %2
:READ_LIST_LOOP
    IF !%3! GEQ !READ_LIST_length! (
        call :ABORT "expected ')', got EOF"
    )

    call :VECTOR_GET READ_LIST_token %2 %3
    IF "!READ_LIST_token!"==")" (
        set /a "%3+=1"
        call :LIST_REVERSE tmp %1
        set "%1=!tmp!"
        EXIT /B 0
    )

    call :READ_FORM form%_recursive_count% %2 %3
    call :CONS %1 form%_recursive_count% %1

    GOTO :READ_LIST_LOOP
EXIT /B 0

:READ_VECTOR
    set /a "%3+=1"
    call :VECTOR_NEW %1
    call :VECTOR_LENGTH READ_LIST_length %2
:READ_VECTOR_LOOP
    IF !%3! GEQ !READ_LIST_length! (
        call :ABORT "expected ']', got EOF"
    )

    call :VECTOR_GET READ_LIST_token %2 %3
    IF "!READ_LIST_token!"=="]" (
        set /a "%3+=1"
        EXIT /B 0
    )

    call :READ_FORM form%_recursive_count% %2 %3
    call :VECTOR_PUSH %1 form%_recursive_count%

    GOTO :READ_VECTOR_LOOP
EXIT /B 0

:IS_NUMERIC
    set "%1=!FALSE!"
    IF "!%2:~0,1!"=="1" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,1!"=="2" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,1!"=="3" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,1!"=="4" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,1!"=="5" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,1!"=="6" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,1!"=="7" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,1!"=="8" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,1!"=="9" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,1!"=="0" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,2!"=="-1" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,2!"=="-2" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,2!"=="-3" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,2!"=="-4" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,2!"=="-5" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,2!"=="-6" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,2!"=="-7" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,2!"=="-8" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,2!"=="-9" (set "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,2!"=="-0" (set "%1=!TRUE!" & EXIT /B 0)
EXIT /B 0

:READ_ATOM
    call :VECTOR_GET READ_ATOM_token %2 %3
    call :ATOM_NEW %1 READ_ATOM_token
    set /a "%3+=1"
EXIT /B 0

:READ_NUMBER
    call :VECTOR_GET READ_ATOM_token %2 %3
    call :NUMBER_NEW %1 READ_ATOM_token
    set /a "%3+=1"
EXIT /B 0

:READ_HASHMAP
    call :HASHMAP_NEW %1
    set /a "%3+=1"

:READ_HASHMAP_LOOP
    call :VECTOR_GET READ_HASHMAP_key%_recursive_count% %2 %3
    set /a "%3+=1"
    IF "!READ_HASHMAP_key%_recursive_count%!"=="}" (
        EXIT /B 0
    )

    call :READ_FORM READ_HASHMAP_value%_recursive_count% %2 %3

    call :HASHMAP_INSERT %1 READ_HASHMAP_key%_recursive_count% READ_HASHMAP_value%_recursive_count%

    GOTO :READ_HASHMAP_LOOP
EXIT /B 0

:READ_PREFIX
    set /a "%3+=1"

    set "%1=!NIL!"
    call :ATOM_NEW READ_PREFIX_atom%_recursive_count% %4
    call :READ_FORM READ_PREFIX_form%_recursive_count% %2 %3
    call :CONS %1 READ_PREFIX_form%_recursive_count% %1
    call :CONS %1 READ_PREFIX_atom%_recursive_count% %1
EXIT /B 0

:READ_PREFIX2
    set /a "%3+=1"

    set "%1=!NIL!"
    call :ATOM_NEW READ_PREFIX_atom%_recursive_count% %4
    call :READ_FORM READ_PREFIX_form%_recursive_count% %2 %3
    call :READ_FORM READ_PREFIX_form2%_recursive_count% %2 %3
    call :CONS %1 READ_PREFIX_form%_recursive_count% %1
    call :CONS %1 READ_PREFIX_form2%_recursive_count% %1
    call :CONS %1 READ_PREFIX_atom%_recursive_count% %1
EXIT /B 0

:READ_FORM
:: To get around the limitation of no local variables,
:: we keep a recursion count to diffirentiate variables
:: for each recursion level.

:: This can be solved better in the future by making them tail-recursive
    set /a "_recursive_count+=1"
    call :VECTOR_LENGTH READ_FORM_length %2
    IF !%3! GEQ !READ_FORM_length! (
        call :ABORT "Unexpected EOF"
    )

    :: These IF statements slow down the reader significantly, can we
    :: branch some other way to make it faster?
    call :VECTOR_GET READ_FORM_token %2 %3
    IF "!READ_FORM_token!"=="(" (
        call :READ_LIST READ_FORM_form%_recursive_count% %2 %3
        GOTO :READ_FORM_EXIT
    )

    IF "!READ_FORM_token!"=="{" (
        call :READ_HASHMAP READ_FORM_form%_recursive_count% %2 %3
        GOTO :READ_FORM_EXIT
    )

    IF "!READ_FORM_token!"=="[" (
        call :READ_VECTOR READ_FORM_form%_recursive_count% %2 %3
        GOTO :READ_FORM_EXIT
    )

    IF "!READ_FORM_token!"=="!_singlequote!" (
        set "READ_FORM_quote=quote"
        call :READ_PREFIX READ_FORM_form%_recursive_count% %2 %3 READ_FORM_quote
        GOTO :READ_FORM_EXIT
    )

    IF "!READ_FORM_token!"=="!_backtick!" (
        set "READ_FORM_quote=quasiquote"
        call :READ_PREFIX READ_FORM_form%_recursive_count% %2 %3 READ_FORM_quote
        GOTO :READ_FORM_EXIT
    )

    IF "!READ_FORM_token!"=="!_tilde!" (
        set "READ_FORM_quote=unquote"
        call :READ_PREFIX READ_FORM_form%_recursive_count% %2 %3 READ_FORM_quote
        GOTO :READ_FORM_EXIT
    )

    IF "!READ_FORM_token!"=="!_splice_unquote!" (
        set "READ_FORM_quote=splice-unquote"
        call :READ_PREFIX READ_FORM_form%_recursive_count% %2 %3 READ_FORM_quote
        GOTO :READ_FORM_EXIT
    )

    IF "!READ_FORM_token!"=="@" (
        set "READ_FORM_quote=deref"
        call :READ_PREFIX READ_FORM_form%_recursive_count% %2 %3 READ_FORM_quote
        GOTO :READ_FORM_EXIT
    )

    IF "!READ_FORM_token!"=="!_with_meta!" (
        set "READ_FORM_quote=with-meta"
        call :READ_PREFIX2 READ_FORM_form%_recursive_count% %2 %3 READ_FORM_quote
        GOTO :READ_FORM_EXIT
    )

    call :IS_NUMERIC READ_FORM_is_numeric READ_FORM_token
    IF "!READ_FORM_is_numeric!"=="!TRUE!" (
        call :READ_NUMBER READ_FORM_form%_recursive_count% %2 %3
        GOTO :READ_FORM_EXIT
    )

    call :READ_ATOM READ_FORM_form%_recursive_count% %2 %3

:READ_FORM_EXIT
    set "%1=!READ_FORM_form%_recursive_count%!"
    set /a "_recursive_count-=1"
EXIT /B 0

:READ_STR
    call :TOKENIZER READ_STR_tokens %2
    set "_recursive_count=0"
    set "READ_STR_index=0"
    call :READ_FORM %1 READ_STR_tokens READ_STR_index
EXIT /B 0

:PR_STR
:: To get around the limitation of no local variables,
:: we keep a recursion count to diffirentiate variables
:: for each recursion level.

:: This can be solved better in the future by making them tail-recursive
    set "_recursive_count=0"
    call :_PR_STR %1 %2
EXIT /B 0

:_PR_STR
    set /a "_recursive_count+=1"

    call :ATOM? PR_STR_is_atom %2
    IF "!PR_STR_is_atom!"=="!TRUE!" (
        call :ATOM_TO_STR PR_STR_tmp %2
        set "%1=!PR_STR_tmp!"
        set /a "_recursive_count-=1"
        EXIT /B 0
    )

    call :NUMBER? PR_STR_is_number %2
    IF "!PR_STR_is_number!"=="!TRUE!" (
        call :NUMBER_TO_STR PR_STR_tmp %2
        set "%1=!PR_STR_tmp!"
        set /a "_recursive_count-=1"
        EXIT /B 0
    )

    call :FUNCTION? PR_STR_is_function %2
    IF "!PR_STR_is_function!"=="!TRUE!" (
        set "%1=#<function>"
        set /a "_recursive_count-=1"
        EXIT /B 0
    )

    call :LIST? PR_STR_is_list %2
    IF "!PR_STR_is_list!"=="!TRUE!" (
        set "%1=("
        set "_PR_STR_tail%_recursive_count%=!%2!"
:_PR_STR_LIST_LOOP
        call :NIL? _PR_STR_is_nil _PR_STR_tail%_recursive_count%
        IF "!_PR_STR_is_nil!"=="!FALSE!" (
            call :FIRST _PR_STR_form _PR_STR_tail%_recursive_count%
            call :REST _PR_STR_tail%_recursive_count% _PR_STR_tail%_recursive_count%

            call :_PR_STR PR_STR_str%_recursive_count% _PR_STR_form

            set "%1=!%1!!PR_STR_str%_recursive_count%!"
            call :NIL? _PR_STR_is_nil _PR_STR_tail%_recursive_count%
            IF "!_PR_STR_is_nil!"=="!FALSE!" (
                set "%1=!%1! "
            )
            GOTO :_PR_STR_LIST_LOOP
        )

        set "%1=!%1!)"
        set /a "_recursive_count-=1"
        EXIT /B 0
    )

    call :VECTOR? PR_STR_is_vector %2
    IF "!PR_STR_is_vector!"=="!TRUE!" (
        call :VECTOR_LENGTH PR_STR_length %2
        set /a "PR_STR_length-=1"
        set "%1=["
        FOR /L %%G IN (0, 1, !PR_STR_length!) DO (
            set "PR_STR_index=%%G"
            call :VECTOR_GET PR_STR_item%_recursive_count% %2 PR_STR_index
            call :_PR_STR PR_STR_str%_recursive_count% PR_STR_item%_recursive_count%
            IF %%G NEQ 0 (
                set "%1=!%1! "
            )
            set "%1=!%1!!PR_STR_str%_recursive_count%!"
        )
        set "%1=!%1!]"

        set /a "_recursive_count-=1"
        EXIT /B 0
    )

    call :HASHMAP? PR_STR_is_hashmap %2
    IF "!PR_STR_is_hashmap!"=="!TRUE!" (
        call :HASHMAP_KEYS PR_STR_keys%_recursive_count% %2
        call :VECTOR_LENGTH PR_STR_length PR_STR_keys%_recursive_count%
        set /a "PR_STR_length-=1"
        set "%1={"
        FOR /L %%G IN (0, 1, !PR_STR_length!) DO (
            set "PR_STR_index=%%G"
            call :VECTOR_GET PR_STR_key%_recursive_count% PR_STR_keys%_recursive_count% PR_STR_index
            call :HASHMAP_GET PR_STR_value%_recursive_count% %2 PR_STR_key%_recursive_count%
            call :_PR_STR PR_STR_str%_recursive_count% PR_STR_value%_recursive_count%
            IF %%G NEQ 0 (
                set "%1=!%1! "
            )
            set "%1=!%1!!PR_STR_key%_recursive_count%! !PR_STR_str%_recursive_count%!"
        )
        set "%1=!%1!}"

        set /a "_recursive_count-=1"
        EXIT /B 0
    )

    echo !%2!
    call :ABORT "Unexpected type !%2:~0,1!"
EXIT /B 0

:CALL_STACK_PUSH
    set /a "_call_stack_size+=1"
    set "_call_stack_value!_call_stack_size!=!%1!"
EXIT /B 0

:CALL_STACK_POP
    set "CALL_STACK_POP_ref=_call_stack_value!_call_stack_size!"
    set "%1=!%CALL_STACK_POP_ref%!"
    set /a "_call_stack_size-=1"
EXIT /B 0

:NUMBER_ADD
    CALL :CALL_STACK_POP NUMBER_ADD_first
    CALL :CALL_STACK_POP NUMBER_ADD_second
    CALL :NUMBER_TO_STR NUMBER_ADD_first_str NUMBER_ADD_first
    CALL :NUMBER_TO_STR NUMBER_ADD_second_str NUMBER_ADD_second
    set /a "NUMBER_ADD_value_str=!NUMBER_ADD_first_str!+!NUMBER_ADD_second_str!"
    CALL :NUMBER_NEW NUMBER_ADD_value NUMBER_ADD_value_str
    CALL :CALL_STACK_PUSH NUMBER_ADD_value
EXIT /B 0

:NUMBER_SUBTRACT
    CALL :CALL_STACK_POP NUMBER_SUBTRACT_first
    CALL :CALL_STACK_POP NUMBER_SUBTRACT_second
    CALL :NUMBER_TO_STR NUMBER_SUBTRACT_first_str NUMBER_SUBTRACT_first
    CALL :NUMBER_TO_STR NUMBER_SUBTRACT_second_str NUMBER_SUBTRACT_second
    set /a "NUMBER_SUBTRACT_value_str=!NUMBER_SUBTRACT_first_str!-!NUMBER_SUBTRACT_second_str!"
    CALL :NUMBER_NEW NUMBER_SUBTRACT_value NUMBER_SUBTRACT_value_str
    CALL :CALL_STACK_PUSH NUMBER_SUBTRACT_value
EXIT /B 0

:NUMBER_MULTIPLY
    CALL :CALL_STACK_POP NUMBER_MULTIPLY_first
    CALL :CALL_STACK_POP NUMBER_MULTIPLY_second
    CALL :NUMBER_TO_STR NUMBER_MULTIPLY_first_str NUMBER_MULTIPLY_first
    CALL :NUMBER_TO_STR NUMBER_MULTIPLY_second_str NUMBER_MULTIPLY_second
    set /a "NUMBER_MULTIPLY_value_str=!NUMBER_MULTIPLY_first_str!*!NUMBER_MULTIPLY_second_str!"
    CALL :NUMBER_NEW NUMBER_MULTIPLY_value NUMBER_MULTIPLY_value_str
    CALL :CALL_STACK_PUSH NUMBER_MULTIPLY_value
EXIT /B 0

:NUMBER_DIVIDE
    CALL :CALL_STACK_POP NUMBER_DIVIDE_first
    CALL :CALL_STACK_POP NUMBER_DIVIDE_second
    CALL :NUMBER_TO_STR NUMBER_DIVIDE_first_str NUMBER_DIVIDE_first
    CALL :NUMBER_TO_STR NUMBER_DIVIDE_second_str NUMBER_DIVIDE_second
    set /a "NUMBER_DIVIDE_value_str=!NUMBER_DIVIDE_first_str!/!NUMBER_DIVIDE_second_str!"
    CALL :NUMBER_NEW NUMBER_DIVIDE_value NUMBER_DIVIDE_value_str
    CALL :CALL_STACK_PUSH NUMBER_DIVIDE_value
EXIT /B 0

:DEFINE_FUN
    set "DEFINE_FUN_key=%2"
    CALL :FUNCTION_NEW DEFINE_FUN_value %3
    CALL :HASHMAP_INSERT %1 DEFINE_FUN_key DEFINE_FUN_value
EXIT /B 0

:START

CALL :HASHMAP_NEW REPL_env
CALL :DEFINE_FUN REPL_env + :NUMBER_ADD
CALL :DEFINE_FUN REPL_env - :NUMBER_SUBTRACT
CALL :DEFINE_FUN REPL_env * :NUMBER_MULTIPLY
CALL :DEFINE_FUN REPL_env / :NUMBER_DIVIDE

:REPL
    set "_input="
    call :READ REPL_form
    set "REPL_result=!NIL!"
    call :EVAL REPL_result REPL_form REPL_env
    call :PRINT REPL_result
GOTO :REPL

:READ
    :: prompt the user and assign the user's input to _input.
    set /p "_input=user> "
    :: If nothing is written, empty the input and reset the error level
    if errorlevel 1 set "_input=" & verify>nul

    IF "!_input!"=="exit" EXIT :: Exit command used for testing purposes

    call :READ_STR %1 _input
EXIT /B 0

:PRINT
    call :PR_STR PRINT_output %1
    call :ECHO PRINT_output
EXIT /B 0

:EVAL_AST
    CALL :LIST? EVAL_AST_is_list %2
    IF "!EVAL_AST_is_list!"=="!TRUE!" (
        CALL :LIST_MAP %1 %2 :EVAL %3
        EXIT /B 0
    )

    CALL :VECTOR? EVAL_AST_is_vector %2
    IF "!EVAL_AST_is_vector!"=="!TRUE!" (
        CALL :VECTOR_LENGTH EVAL_AST_vector_length %2
        set /a "EVAL_AST_vector_length-=1"
        CALL :VECTOR_NEW EVAL_AST_new_vector%_recursive_count%
        FOR /L %%G IN (0, 1, !EVAL_AST_vector_length!) DO (
            set "EVAL_AST_index=%%G"
            CALL :VECTOR_GET EVAL_AST_form%_recursive_count% %2 EVAL_AST_index
            CALL :EVAL EVAL_AST_evaluated%_recursive_count% EVAL_AST_form%_recursive_count% %3
            CALL :VECTOR_PUSH EVAL_AST_new_vector%_recursive_count% EVAL_AST_evaluated%_recursive_count%
        )
        set "%1=!EVAL_AST_new_vector%_recursive_count%!"
        EXIT /B 0
    )

    CALL :HASHMAP? EVAL_AST_is_hashmap %2
    IF "!EVAL_AST_is_hashmap!"=="!TRUE!" (
        CALL :HASHMAP_KEYS EVAL_AST_keys%_recursive_count% %2
        CALL :VECTOR_LENGTH EVAL_AST_keys_length EVAL_AST_keys%_recursive_count%
        set /a "EVAL_AST_keys_length-=1"
        CALL :HASHMAP_NEW EVAL_AST_new_hashmap%_recursive_count%
        FOR /L %%G IN (0, 1, !EVAL_AST_keys_length!) DO (
            set "EVAL_AST_index=%%G"
            CALL :VECTOR_GET EVAL_AST_key%_recursive_count% EVAL_AST_keys%_recursive_count% EVAL_AST_index
            CALL :HASHMAP_GET EVAL_AST_value%_recursive_count% %2 EVAL_AST_key%_recursive_count%
            CALL :EVAL EVAL_AST_evaluated%_recursive_count% EVAL_AST_value%_recursive_count% %3
            CALL :HASHMAP_INSERT EVAL_AST_new_hashmap%_recursive_count% EVAL_AST_key%_recursive_count% EVAL_AST_evaluated%_recursive_count%
        )
        set "%1=!EVAL_AST_new_hashmap%_recursive_count%!"
        EXIT /B 0
    )

    CALL :ATOM? EVAL_AST_is_atom %2
    IF "!EVAL_AST_is_atom!"=="!TRUE!" (
        CALL :ATOM_TO_STR EVAL_AST_atom_str%_recursive_count% %2
        CALL :HASHMAP_GET %1 %3 EVAL_AST_atom_str%_recursive_count%
        EXIT /B 0
    )

    set "%1=!%2!"
EXIT /B 0

:EVAL
    set /a "_recursive_count+=1"

    CALL :LIST? EVAL_is_list %2
    IF "!EVAL_is_list!"=="!TRUE!" (
        IF "!%2!"=="!NIL!" (
            set "%1=!%2!"
            set /a "_recursive_count-=1"
            EXIT /B 0
        )

        CALL :EVAL_AST EVAL_list%_recursive_count% %2 %3

        CALL :FIRST EVAL_function%_recursive_count% EVAL_list%_recursive_count%
        CALL :FUNCTION_TO_STR EVAL_function_str%_recursive_count% EVAL_function%_recursive_count%

        CALL :REST EVAL_list%_recursive_count% EVAL_list%_recursive_count%
        CALL :FIRST EVAL_a%_recursive_count% EVAL_list%_recursive_count%

        CALL :REST EVAL_list%_recursive_count% EVAL_list%_recursive_count%
        CALL :FIRST EVAL_b%_recursive_count% EVAL_list%_recursive_count%

        CALL :CALL_STACK_PUSH EVAL_b%_recursive_count%
        CALL :CALL_STACK_PUSH EVAL_a%_recursive_count%
        CALL !EVAL_function_str%_recursive_count%!
        CALL :CALL_STACK_POP %1

        set /a "_recursive_count-=1"
        EXIT /B 0
    )

    CALL :EVAL_AST %1 %2 %3

    set /a "_recursive_count-=1"
EXIT /B 0
