:: The following file is generated by build.bat. DO NOT EDIT. 
@echo off
SETLOCAL ENABLEEXTENSIONS ENABLEDELAYEDEXPANSION

:: While macros
SET BREAK=EXIT
SET WHILE=IF "%1"=="fi301kvnro2qa9vm2" (FOR /L %%? IN () DO IF
SET DO=(
SET END_WHILE=) ELSE %BREAK%) ELSE CMD /Q /C "%~F0" fi301kvnro2qa9vm2

:: Magic number that says we're calling a loop
IF "%1"=="fi301kvnro2qa9vm2" GOTO %2

SET "NIL="
SET "EMPTY_LIST=l"
SET "TRUE=t"
SET "FALSE=f"

SET _newline_escape=\n
SET _doublequote_escape=\"
SET _backslash_escape=\\

SET _doublequote=^"
SET _backslash=^\
SET _singlequote=^'
SET _backtick=^`
SET _tilde=^~
SET _splice_unquote=^~^@
SET _with_meta=^^
SET _greater_than=^>
SET _lower_than=^<
SET _greater_than_equal=^>^=
SET _lower_than_equal=^<^=
SET _equal=^=
SET _plus=^+
SET _minus=^-
SET _slash=^/
SET _asterisk=^*
SET _colon=^:
SET _ampersand=^&
SET _newline=^


:: Do not remove the empty lines above

GOTO :START

:ECHO
    IF NOT "!%1!"=="" (
        echo !%1!
    ) ELSE (
        echo[
    )
EXIT /B 0

:ABORT
    :: With to many calls to abort the stack starts to fill up.
    :: Better to return an error value instead.
    ECHO %~1
    GOTO :START
EXIT

:NIL?
    IF "!%~2!"=="" (
        SET "%~1=!TRUE!"
    ) ELSE (
        SET "%~1=!FALSE!"
    )
EXIT /B 0

:CONS
    SET /a "_list_counter+=1"
    SET "_list_first_!_list_counter!=!%~2!"
    SET "_list_rest_!_list_counter!=!%~3!"
    SET "%~1=L!_list_counter!"
EXIT /B 0

:FIRST
    SET "ref=_list_first_!%~2:~1,8191!"
    SET "%1=!%ref%!"
EXIT /B 0

:REST
    SET "ref=_list_rest_!%~2:~1,8191!"
    SET "%1=!%ref%!"
EXIT /B 0

:LIST?
    IF "!%2!"=="!EMPTY_LIST!" (
        SET "%~1=!TRUE!"
    ) ELSE (
        IF "!%~2:~0,1!"=="L" (
            SET "%~1=!TRUE!"
        ) ELSE (
            SET "%~1=!FALSE!"
        )
    )
EXIT /B 0

:LIST_EMPTY?
    IF "!%2!"=="!EMPTY_LIST!" (
        SET "%~1=!TRUE!"
    ) ELSE (
        SET "%~1=!FALSE!"
    )
EXIT /B 0

:LIST_COUNT
    SET "%1=0"

    IF "!%2!"=="!NIL!" (
        EXIT /B 0
    )

    SET "LIST_COUNT_list=!%2!"

:LIST_COUNT_LOOP
    IF NOT "!LIST_COUNT_list!"=="!EMPTY_LIST!" (
        CALL :REST LIST_COUNT_list LIST_COUNT_list
        SET /a "%1+=1"
        GOTO :LIST_COUNT_LOOP
    )
EXIT /B 0

:LIST_REVERSE
    SET "LIST_REVERSE_new_list=!EMPTY_LIST!"
    CALL :_LIST_REVERSE LIST_REVERSE_new_list %2
    SET "%1=!LIST_REVERSE_new_list!"
EXIT /B 0

:_LIST_REVERSE
    IF "!%2!"=="!EMPTY_LIST!" (
        EXIT /B 0
    )

    CALL :FIRST LIST_REVERSE_first %2
    CALL :REST LIST_REVERSE_rest %2

    CALL :CONS %1 LIST_REVERSE_first %1

    CALL :_LIST_REVERSE %1 LIST_REVERSE_rest
EXIT /B 0

:LIST_MAP
    SET /A "LIST_MAP_recursion_count+=1"
    SET "LIST_MAP_list%LIST_MAP_recursion_count%=!EMPTY_LIST!"
    CALL :_LIST_MAP LIST_MAP_list%LIST_MAP_recursion_count% %2 %3 %4
    CALL :LIST_REVERSE %1 LIST_MAP_list%LIST_MAP_recursion_count%
    SET /A "LIST_MAP_recursion_count-=1"
EXIT /B 0

:_LIST_MAP
    IF "!%2!"=="!EMPTY_LIST!" (
        EXIT /B 0
    )

    CALL :FIRST LIST_MAP_first%LIST_MAP_recursion_count% %2
    CALL :REST LIST_MAP_rest%LIST_MAP_recursion_count% %2

    CALL %3 LIST_MAP_mapped%LIST_MAP_recursion_count% LIST_MAP_first%LIST_MAP_recursion_count% %4

    CALL :CONS %1 LIST_MAP_mapped%LIST_MAP_recursion_count% %1

    CALL :_LIST_MAP %1 LIST_MAP_rest%LIST_MAP_recursion_count% %3 %4
EXIT /B 0

:LIST_FIND
    SET /A "LIST_FIND_recursion_count+=1"
    CALL :_LIST_FIND %1 %2 %3 %4
    SET /A "LIST_FIND_recursion_count-=1"
EXIT /B 0

:_LIST_FIND
    IF "!%2!"=="!EMPTY_LIST!" (
        SET "%1=!NIL!"
        EXIT /B 0
    )

    CALL :FIRST LIST_FIND_first%LIST_FIND_recursion_count% %2
    CALL :REST LIST_FIND_rest%LIST_FIND_recursion_count% %2

    CALL %3 LIST_FIND_predicate%LIST_FIND_recursion_count% LIST_FIND_first%LIST_FIND_recursion_count% %4

    IF "!LIST_FIND_predicate%LIST_FIND_recursion_count%!"=="!TRUE!" (
        SET "%1=!LIST_FIND_first%LIST_FIND_recursion_count%!"
        EXIT /B 0
    )

    CALL :_LIST_FIND %1 LIST_FIND_rest%LIST_FIND_recursion_count% %3 %4
EXIT /B 0

:LIST_EQUAL
    SET /A "LIST_EQUAL_recursion_count+=1"
    SET "LIST_EQUAL_rest_left%LIST_EQUAL_recursion_count%=!%2!"
    SET "LIST_EQUAL_rest_right%LIST_EQUAL_recursion_count%=!%3!"
    CALL :_LIST_EQUAL %1
    SET /A "LIST_EQUAL_recursion_count-=1"
EXIT /B 0

:_LIST_EQUAL
    IF "!LIST_EQUAL_rest_left%LIST_EQUAL_recursion_count%!"=="!EMPTY_LIST!" (
        IF "!LIST_EQUAL_rest_right%LIST_EQUAL_recursion_count%!"=="!EMPTY_LIST!" (
            SET "%1=!TRUE!"
        ) ELSE (
            SET "%1=!FALSE!"
        )
        EXIT /B 0
    )

    CALL :FIRST LIST_EQUAL_first_left%LIST_EQUAL_recursion_count% LIST_EQUAL_rest_left%LIST_EQUAL_recursion_count%
    CALL :REST LIST_EQUAL_rest_left%LIST_EQUAL_recursion_count% LIST_EQUAL_rest_left%LIST_EQUAL_recursion_count%

    CALL :FIRST LIST_EQUAL_first_right%LIST_EQUAL_recursion_count% LIST_EQUAL_rest_right%LIST_EQUAL_recursion_count%
    CALL :REST LIST_EQUAL_rest_right%LIST_EQUAL_recursion_count% LIST_EQUAL_rest_right%LIST_EQUAL_recursion_count%

    CALL :EQUAL? %1 LIST_EQUAL_first_left%LIST_EQUAL_recursion_count% LIST_EQUAL_first_right%LIST_EQUAL_recursion_count%

    IF "!%1!"=="!FALSE!" EXIT /B 0

    GOTO :_LIST_EQUAL
EXIT /B 0

:LIST_LAST
    IF "!%2!"=="!EMPTY_LIST!" (
        SET "%1=!NIL!"
        EXIT /B 0
    )
    SET "LIST_LAST_list=!%2!"
:LIST_LAST_LOOP

    CALL :REST LIST_LAST_rest LIST_LAST_list

    IF "!LIST_LAST_rest!"=="!EMPTY_LIST!" (
        CALL :FIRST %1 LIST_LAST_list
        EXIT /B 0
    )

    SET "LIST_LAST_list=!LIST_LAST_rest!"
    GOTO :LIST_LAST_LOOP
EXIT /B 0

:LIST_WITHOUT_LAST
    CALL :LIST_REVERSE LIST_WITHOUT_LAST_list %2
    CALL :REST LIST_WITHOUT_LAST_list LIST_WITHOUT_LAST_list
    CALL :LIST_REVERSE %1 LIST_WITHOUT_LAST_list
EXIT /B 0

:LIST_CONCAT
    CALL :LIST_REVERSE LIST_CONCAT_first %2
    SET "LIST_CONCAT_second=!%3!"
:LIST_CONCAT_RECUR
    IF "!LIST_CONCAT_first!"=="!EMPTY_LIST!" (
        SET "%1=!LIST_CONCAT_second!"
        EXIT /B 0
    )

    CALL :FIRST LIST_CONCAT_item LIST_CONCAT_first
    CALL :REST LIST_CONCAT_first LIST_CONCAT_first

    CALL :CONS LIST_CONCAT_second LIST_CONCAT_item LIST_CONCAT_second

    GOTO :LIST_CONCAT_RECUR
EXIT /B 0

:VECTOR_NEW
    SET /a "_vector_counter+=1"
    SET "_vector_length_!_vector_counter!=0"
    SET "%1=V!_vector_counter!"
EXIT /B 0

:VECTOR_LENGTH
    SET "_length=_vector_length_!%2:~1,8191!"
    SET "%1=!%_length%!"
EXIT /B 0

:VECTOR_EMPTY?
    SET "_length=_vector_length_!%2:~1,8191!"
    IF "!%_length%!"=="0" (
        SET "%1=!TRUE!"
    ) ELSE (
        SET "%1=!FALSE!"
    )
EXIT /B 0

:VECTOR_GET
    SET "_ref=_vector_!%2:~1,8191!_!%3!"
    SET "%1=!%_ref%!"
EXIT /B 0

:VECTOR_PUSH
    SET "_id=!%1:~1,8191!"
    SET "_length=_vector_length_!_id!"
    SET "_ref=_vector_!_id!_!%_length%!"
    SET "%_ref%=!%2!"
    SET /a "%_length%+=1"
EXIT /B 0

:VECTOR_MAP
    SET /A "VECTOR_MAP_recursion_count+=1"
    CALL :_VECTOR_MAP %1 %2 %3 %4
    SET /A VECTOR_MAP_recursion_count-=1"
EXIT /B 0

:_VECTOR_MAP
    CALL :VECTOR_LENGTH VECTOR_MAP_vector_length%VECTOR_MAP_recursion_count% %2
    SET /a "VECTOR_MAP_vector_length%VECTOR_MAP_recursion_count%-=1"
    CALL :VECTOR_NEW VECTOR_MAP_new_vector%VECTOR_MAP_recursion_count%
    FOR /L %%G IN (0, 1, !VECTOR_MAP_vector_length%VECTOR_MAP_recursion_count%!) DO (
        SET "VECTOR_MAP_index%VECTOR_MAP_recursion_count%=%%G"
        CALL :VECTOR_GET VECTOR_MAP_value%VECTOR_MAP_recursion_count% %2 VECTOR_MAP_index%VECTOR_MAP_recursion_count%
        CALL %3 VECTOR_MAP_mapped%VECTOR_MAP_recursion_count% VECTOR_MAP_value%VECTOR_MAP_recursion_count% %4
        CALL :VECTOR_PUSH VECTOR_MAP_new_vector%VECTOR_MAP_recursion_count% VECTOR_MAP_mapped%VECTOR_MAP_recursion_count%
    )
    SET "%1=!VECTOR_MAP_new_vector%VECTOR_MAP_recursion_count%!"
EXIT /B 0

:VECTOR_TO_LIST
    CALL :VECTOR_LENGTH VECTOR_TO_LIST_length %2
    SET "VECTOR_TO_LIST_list=!EMPTY_LIST!"
    SET /A "VECTOR_TO_LIST_length-=1"
    FOR /L %%G IN (0, 1, !VECTOR_TO_LIST_length!) DO (
        SET "VECTOR_TO_LIST_index=%%G"
        CALL :VECTOR_GET VECTOR_TO_LIST_value %2 VECTOR_TO_LIST_index
        CALL :CONS VECTOR_TO_LIST_list VECTOR_TO_LIST_value VECTOR_TO_LIST_list
    )
    CALL :LIST_REVERSE VECTOR_TO_LIST_list VECTOR_TO_LIST_list
    SET "%1=!VECTOR_TO_LIST_list!"
EXIT /B 0

:VECTOR?
    IF "!%2:~0,1!"=="V" (
        SET "%1=!TRUE!"
    ) ELSE (
        SET "%1=!FALSE!"
    )
EXIT /B 0


:STRING_NEW
    SET /a "_string_counter+=1"
    SET "_length=_string_length_!_string_counter!"
    CALL :STRLEN %_length% %2
    SET "_string_contents_!_string_counter!=!%2!"
    SET "%1=S!_string_counter!"
EXIT /B 0

:STRING_LENGTH
    SET "_length=_string_length_!%2:~1,8191!"
    SET "%1=!%_length%!"
EXIT /B 0

:STRING_TO_STR
    SET "_ref=_string_contents_!%2:~1,8191!"
    SET "%1=!%_ref%!"
EXIT /B 0

:STRING_EQUAL
    SET "STRING_EQUAL_first=_string_contents_!%2:~1,8191!"
    SET "STRING_EQUAL_second=_string_contents_!%3:~1,8191!"
    IF "!%STRING_EQUAL_first%!"=="!%STRING_EQUAL_second%!" (
        SET "%1=!TRUE!"
    ) ELSE (
        SET "%1=!FALSE!"
    )
EXIT /B 0

:STRING?
    IF "!%2:~0,1!"=="S" (
        SET "%1=!TRUE!"
    ) ELSE (
        SET "%1=!FALSE!"
    )
EXIT /B 0


:SYMBOL_NEW
    SET /a "_symbol_counter+=1"
    SET "_length=_symbol_length_!_symbol_counter!"
    CALL :STRLEN %_length% %2
    SET "_symbol_contents_!_symbol_counter!=!%2!"
    SET "%1=A!_symbol_counter!"
EXIT /B 0

:SYMBOL_LENGTH
    SET "_length=_symbol_length_!%2:~1,8191!"
    SET "%1=!%_length%!"
EXIT /B 0

:SYMBOL_TO_STR
    SET "_ref=_symbol_contents_!%2:~1,8191!"
    SET "%1=!%_ref%!"
EXIT /B 0

:SYMBOL_EQUAL
    SET "SYMBOL_EQUAL_first=_symbol_contents_!%2:~1,8191!"
    SET "SYMBOL_EQUAL_second=_symbol_contents_!%3:~1,8191!"
    IF "!%SYMBOL_EQUAL_first%!"=="!%SYMBOL_EQUAL_second%!" (
        SET "%1=!TRUE!"
    ) ELSE (
        SET "%1=!FALSE!"
    )
EXIT /B 0

:SYMBOL?
    IF "!%2:~0,1!"=="A" (
        SET "%1=!TRUE!"
    ) ELSE (
        SET "%1=!FALSE!"
    )
EXIT /B 0



:ATOM_NEW
    SET /a "_atom_counter+=1"
    SET "_atom_value_!_atom_counter!=!%2!"
    SET "%1=T!_atom_counter!"
EXIT /B 0

:ATOM_DEREF
    SET "_ref=_atom_value_!%2:~1,8191!"
    SET "%1=!%_ref%!"
EXIT /B 0

:ATOM_RESET
    SET "_ref=_atom_value_!%2:~1,8191!"
    SET "%_ref%=!%3!"
    SET "%1=!%3!"
EXIT /B 0

:ATOM?
    IF "!%2:~0,1!"=="T" (
        SET "%1=!TRUE!"
    ) ELSE (
        SET "%1=!FALSE!"
    )
EXIT /B 0


:FUNCTION_NEW
    SET /a "_function_counter+=1"
    SET "_function_name_!_function_counter!=!%2!"
    SET "_function_env_!_function_counter!=!%3!"
    SET "_function_params_!_function_counter!=!%4!"
    SET "_function_body_!_function_counter!=!%5!"
    SET "%1=F!_function_counter!"
EXIT /B 0

:FUNCTION_TO_STR
    SET "_ref=_function_name_!%2:~1,8191!"
    SET "%1=!%_ref%!"
EXIT /B 0

:FUNCTION_GET_ENV
    SET "_ref=_function_env_!%2:~1,8191!"
    SET "%1=!%_ref%!"
EXIT /B 0

:FUNCTION_GET_PARAMS
    SET "_ref=_function_params_!%2:~1,8191!"
    SET "%1=!%_ref%!"
EXIT /B 0

:FUNCTION_GET_BODY
    SET "_ref=_function_body_!%2:~1,8191!"
    SET "%1=!%_ref%!"
EXIT /B 0

:FUNCTION?
    IF "!%2:~0,1!"=="F" (
        SET "%1=!TRUE!"
    ) ELSE (
        SET "%1=!FALSE!"
    )
EXIT /B 0


:NUMBER_NEW
    SET /a "_number_counter+=1"
    SET "_number_value!_number_counter!=!%2!"
    SET "%1=N!_number_counter!"
EXIT /B 0

:NUMBER_TO_STR
    SET "_ref=_number_value!%2:~1,8191!"
    SET "%1=!%_ref%!"
EXIT /B 0

:NUMBER_TO_STRING
    SET "NUMBER_TO_STRING_str=_number_value!%2:~1,8191!"
    CALL :STRING_NEW %1 NUMBER_TO_STRING_str
EXIT /B 0

:NUMBER_EQUAL
    SET "NUMBER_EQUAL_first=_number_value!%2:~1,8191!"
    SET "NUMBER_EQUAL_second=_number_value!%3:~1,8191!"
    IF "!%NUMBER_EQUAL_first%!"=="!%NUMBER_EQUAL_second%!" (
        SET "%1=!TRUE!"
    ) ELSE (
        SET "%1=!FALSE!"
    )
EXIT /B 0

:NUMBER?
    IF "!%2:~0,1!"=="N" (
        SET "%1=!TRUE!"
    ) ELSE (
        SET "%1=!FALSE!"
    )
EXIT /B 0


:HASHMAP_NEW
    SET /a "_hashmap_counter+=1"
    CALL :VECTOR_NEW _hashmap_keys!_hashmap_counter!
    CALL :VECTOR_NEW _hashmap_values!_hashmap_counter!
    SET "%1=H!_hashmap_counter!"
EXIT /B 0

:HASHMAP_INSERT
    SET "HASHMAP_INSERT_id=!%1:~1,8191!"
    CALL :VECTOR_PUSH _hashmap_keys!HASHMAP_INSERT_id! %2
    CALL :VECTOR_PUSH _hashmap_values!HASHMAP_INSERT_id! %3
EXIT /B 0

:_HASHMAP_INDEX_OF_KEY
    SET "_HASHMAP_INDEX_OF_KEY_id=!%2:~1,8191!"
    SET "%1=!NIL!"
    CALL :VECTOR_LENGTH _HASHMAP_INDEX_OF_KEY_length _hashmap_keys!_HASHMAP_INDEX_OF_KEY_id!
    SET /a "_HASHMAP_INDEX_OF_KEY_length-=1"
    FOR /L %%G IN (0, 1, !_HASHMAP_INDEX_OF_KEY_length!) DO (
        SET "_HASHMAP_INDEX_OF_KEY_index=%%G"
        CALL :VECTOR_GET _HASHMAP_INDEX_OF_KEY_key _hashmap_keys!_HASHMAP_INDEX_OF_KEY_id! _HASHMAP_INDEX_OF_KEY_index
        IF "!_HASHMAP_INDEX_OF_KEY_key!"=="!%3!" (
            SET "%1=%%G"
        )
    )
EXIT /B 0

:HASHMAP_GET
    SET "HASHMAP_GET_id=!%2:~1,8191!"
    CALL :_HASHMAP_INDEX_OF_KEY HASHMAP_GET_key_index %2 %3
    IF "!HASHMAP_GET_key_index!"=="!NIL!" (
        SET "%1=!NIL!"
        EXIT /B 0
    )

    CALL :VECTOR_GET %1 _hashmap_values!HASHMAP_GET_id! HASHMAP_GET_key_index
EXIT /B 0

:HASHMAP_KEYS
    SET "_id=!%2:~1,8191!"
    SET "_ref=_hashmap_keys!_id!"
    SET "%1=!%_ref%!"
EXIT /B 0

:HASHMAP_MAP
    SET /A "HASHMAP_MAP_recursion_count+=1"
    CALL :_HASHMAP_MAP %1 %2 %3 %4
    SET /A HASHMAP_MAP_recursion_count-=1"
EXIT /B 0

:_HASHMAP_MAP
    CALL :HASHMAP_KEYS HASHMAP_MAP_keys%HASHMAP_MAP_recursion_count% %2
    CALL :VECTOR_LENGTH HASHMAP_MAP_keys_length%HASHMAP_MAP_recursion_count% HASHMAP_MAP_keys%HASHMAP_MAP_recursion_count%
    SET /a "HASHMAP_MAP_keys_length%HASHMAP_MAP_recursion_count%-=1"
    CALL :HASHMAP_NEW HASHMAP_MAP_new_hashmap%HASHMAP_MAP_recursion_count%
    FOR /L %%G IN (0, 1, !HASHMAP_MAP_keys_length%HASHMAP_MAP_recursion_count%!) DO (
        SET "HASHMAP_MAP_index%HASHMAP_MAP_recursion_count%=%%G"
        CALL :VECTOR_GET HASHMAP_MAP_key%HASHMAP_MAP_recursion_count% HASHMAP_MAP_keys%HASHMAP_MAP_recursion_count% HASHMAP_MAP_index%HASHMAP_MAP_recursion_count%
        CALL :HASHMAP_GET HASHMAP_MAP_value%HASHMAP_MAP_recursion_count% %2 HASHMAP_MAP_key%HASHMAP_MAP_recursion_count%
        CALL %3 HASHMAP_MAP_mapped%HASHMAP_MAP_recursion_count% HASHMAP_MAP_value%HASHMAP_MAP_recursion_count% %4
        CALL :HASHMAP_INSERT HASHMAP_MAP_new_hashmap%HASHMAP_MAP_recursion_count% HASHMAP_MAP_key%HASHMAP_MAP_recursion_count% HASHMAP_MAP_mapped%HASHMAP_MAP_recursion_count%
    )
    SET "%1=!HASHMAP_MAP_new_hashmap%HASHMAP_MAP_recursion_count%!"
EXIT /B 0

:HASHMAP?
    IF "!%2:~0,1!"=="H" (
        SET "%1=!TRUE!"
    ) ELSE (
        SET "%1=!FALSE!"
    )
EXIT /B 0


:ERROR_NEW
    SET /a "_error_counter+=1"
    SET "_error_value!_error_counter!=!%2!"
    SET "%1=R!_error_counter!"
EXIT /B 0

:ERROR_TO_STR
    SET "_ref=_error_value!%2:~1,8191!"
    SET "%1=!%_ref%!"
EXIT /B 0

:ERROR_TO_STRING
    SET "ERROR_TO_STRING_str=_error_value!%2:~1,8191!"
    CALL :STRING_NEW %1 ERROR_TO_STRING_str
EXIT /B 0

:ERROR?
    IF "!%2:~0,1!"=="R" (
        SET "%1=!TRUE!"
    ) ELSE (
        SET "%1=!FALSE!"
    )
EXIT /B 0


:EQUAL?
    SET "EQUAL?_first=!%2!"
    SET "EQUAL?_second=!%3!"

    IF "!EQUAL?_first:~0,1!"=="V" (
        CALL :VECTOR_TO_LIST EQUAL?_first EQUAL?_first
    )
    IF "!EQUAL?_second:~0,1!"=="V" (
        CALL :VECTOR_TO_LIST EQUAL?_second EQUAL?_second
    )

    IF "!EQUAL?_first!"=="!EQUAL?_second!" (
        SET "%1=!TRUE!"
        EXIT /B 0
    ) ELSE (
        IF "!EQUAL?_first:~0,1!"=="!EQUAL?_second:~0,1!" (
            :: Types are the same
            IF "!EQUAL?_first:~0,1!"=="A" (
                CALL :SYMBOL_EQUAL %1 EQUAL?_first EQUAL?_second
                EXIT /B 0
            )
            IF "!EQUAL?_first:~0,1!"=="N" (
                CALL :NUMBER_EQUAL %1 EQUAL?_first EQUAL?_second
                EXIT /B 0
            )
            IF "!EQUAL?_first:~0,1!"=="S" (
                CALL :STRING_EQUAL %1 EQUAL?_first EQUAL?_second
                EXIT /B 0
            )
            IF "!EQUAL?_first:~0,1!"=="L" (
                CALL :LIST_EQUAL %1 EQUAL?_first EQUAL?_second
                EXIT /B 0
            )
        )
    )
    SET "%1=!FALSE!"
EXIT /B 0

:SUBSTRING
    SET "SUBSTRING_start=!%~3!"
    SET "SUBSTRING_length=!%~4!"
    CALL :_SUBSTRING %~1 %~2 %SUBSTRING_start% %SUBSTRING_length%
EXIT /B 0

:_SUBSTRING
    SET /a "_SUBSTRING_end=%~3+%~4-1"
    SET "%~1=!%~2:~%~3,%_SUBSTRING_end%!"
EXIT /B 0

:STRING_CONTAINS_CHAR
    SET "STRING_CONTAINS_CHAR_string=!%~2!"
    SET "STRING_CONTAINS_CHAR_char=!%~3!"

:STRING_CONTAINS_CHAR_LOOP
    IF "!STRING_CONTAINS_CHAR_string!"=="" (
        SET "%~1=!FALSE!"
    )

    IF "!STRING_CONTAINS_CHAR_string:~0,1!"=="!STRING_CONTAINS_CHAR_char!" (
        SET "%~1=!TRUE!"
    ) ELSE (
        SET "STRING_CONTAINS_CHAR_string=!STRING_CONTAINS_CHAR_string:~1,8191!"
        GOTO :STRING_CONTAINS_CHAR_LOOP
    )
EXIT /B 0

:STRLEN
    SET "STRLEN_buffer=#!%2!"
    SET "STRLEN_length=0"
    FOR %%N IN (8192 4096 2048 1024 512 256 128 64 32 16 8 4 2 1) DO (
        IF NOT "!STRLEN_buffer:~%%N,1!"=="" (
            SET /a "STRLEN_length+=%%N"
            SET "STRLEN_buffer=!STRLEN_buffer:~%%N!"
        )
    )
    SET "%1=%STRLEN_length%"
EXIT /B 0

:STRING_REPLACE_CHAR
    SET "STRING_REPLACE_CHAR_dest="
    SET "STRING_REPLACE_CHAR_source=!%2!"

:STRING_REPLACE_CHAR_LOOP
    IF "!STRING_REPLACE_CHAR_source!"=="" (
        SET "%1=!STRING_REPLACE_CHAR_dest!"
        EXIT /B 0
    )

    SET "STRING_REPLACE_CHAR_char=!STRING_REPLACE_CHAR_source:~0,1!"
    SET "STRING_REPLACE_CHAR_source=!STRING_REPLACE_CHAR_source:~1,8191!"

    IF "!STRING_REPLACE_CHAR_char!"=="!%3!" (
        SET "STRING_REPLACE_CHAR_dest=!STRING_REPLACE_CHAR_dest!!%4!"
        GOTO :STRING_REPLACE_CHAR_LOOP
    )

    SET "STRING_REPLACE_CHAR_dest=!STRING_REPLACE_CHAR_dest!!STRING_REPLACE_CHAR_char!"
    GOTO :STRING_REPLACE_CHAR_LOOP
EXIT /B 0

:READ_WHILE
    SET "%1="
:READ_WHILE_LOOP
    IF "!%2!"=="" (
        EXIT /B 0
    )

    SET "READ_WHILE_char=!%2:~0,1!"

    CALL %3 READ_WHILE_did_match READ_WHILE_char

    IF "!READ_WHILE_did_match!"=="!FALSE!" (
        EXIT /B 0
    )
    SET "%1=!%1!!READ_WHILE_char!"
    SET "%2=!%2:~1,8191!"
    GOTO :READ_WHILE_LOOP
EXIT /B 0

:READ_CHARACTER
    SET "%1="

    IF "!%2!"=="" (
        EXIT /B 0
    )

    SET "READ_CHARACTER_char=!%2:~0,1!"

    CALL %3 READ_CHARACTER_did_match READ_CHARACTER_char

    IF "!READ_CHARACTER_did_match!"=="!FALSE!" (
        EXIT /B 0
    )

    SET "%1=!READ_CHARACTER_char!"
    SET "%2=!%2:~1,8191!"
EXIT /B 0

:IS_COMMA_OR_SPACE
    SET "%1=!FALSE!"
    IF "!%2!"=="," (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2!"==" " (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2!"=="!_newline!" (SET "%1=!TRUE!" & EXIT /B 0)
EXIT /B 0

:IS_SPECIAL_CHARACTER
    SET "%1=!FALSE!"
    IF "!%2!"=="[" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2!"=="]" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2!"=="{" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2!"=="}" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2!"=="(" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2!"==")" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2!"=="'" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2!"=="`" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2!"=="~" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2!"=="^" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2!"=="@" (SET "%1=!TRUE!" & EXIT /B 0)
EXIT /B 0

:IS_NOT_DOUBLEQUOTE_OR_BACKSLASH
    SET "%1=!TRUE!"
    IF "!%2!"=="!_doublequote!" (SET "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="!_backslash!" (SET "%1=!FALSE!" & EXIT /B 0)
EXIT /B 0

:IS_SYMBOL_CHARACTER
    SET "%1=!TRUE!"
    IF "!%2!"=="[" (SET "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="]" (SET "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="{" (SET "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="}" (SET "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="(" (SET "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"==")" (SET "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="'" (SET "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="`" (SET "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="~" (SET "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="^" (SET "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="@" (SET "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="," (SET "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"==" " (SET "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"==";" (SET "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="!_newline!" (SET "%1=!FALSE!" & EXIT /B 0)
    IF "!%2!"=="!_doublequote!" (SET "%1=!FALSE!" & EXIT /B 0)
EXIT /B 0

:READ_STRING
    IF "!%2!"=="" (
        SET "%1="
        EXIT /B 0
    )
    CALL :STRLEN READ_STRING_length %3
    SET "READ_STRING_match=!%2:~0,%READ_STRING_length%!"
    IF "!READ_STRING_match!"=="!%3!" (
        SET "%1=!READ_STRING_match!"
        SET "%2=!%2:~%READ_STRING_length%!"
    ) ELSE (
        SET "%1="
    )
EXIT /B 0

:READ_DOUBLEQUOTED_STRING
    SET "%1="

    :: If there is a double-quote, read a quoted string
    IF "!%2:~0,1!"=="!_doublequote!" (
        SET "%1=!%1!!%2:~0,1!"
        SET "%2=!%2:~1,8191!"
:READ_DOUBLEQUOTED_STRING_CONTINUE
        IF "!%2!"=="" (
            EXIT /B 0
        )

        CALL :READ_WHILE READ_DOUBLEQUOTED_STRING_match %2 :IS_NOT_DOUBLEQUOTE_OR_BACKSLASH
        SET "%1=!%1!!READ_DOUBLEQUOTED_STRING_match!"

        IF "!%2!"=="" (
            EXIT /B 0
        )

        SET "READ_DOUBLEQUOTED_STRING_terminator=!%2:~0,1!"
        SET "%2=!%2:~1,8191!"

        :: If the last character was a back-slash, we continue reading the string.
        IF "!READ_DOUBLEQUOTED_STRING_terminator!"=="!_backslash!" (
            SET "READ_DOUBLEQUOTED_STRING_escape=!%2:~0,1!"
            SET "%2=!%2:~1,8191!"

            IF "!READ_DOUBLEQUOTED_STRING_escape!"=="n" (
                SET "%1=!%1!!_newline!"
                GOTO :READ_DOUBLEQUOTED_STRING_CONTINUE
            )

            IF "!READ_DOUBLEQUOTED_STRING_escape!"=="!_doublequote!" (
                SET "%1=!%1!!_doublequote!"
                GOTO :READ_DOUBLEQUOTED_STRING_CONTINUE
            )

            IF "!READ_DOUBLEQUOTED_STRING_escape!"=="!_backslash!" (
                SET "%1=!%1!!_backslash!"
                GOTO :READ_DOUBLEQUOTED_STRING_CONTINUE
            )

            GOTO :READ_DOUBLEQUOTED_STRING_CONTINUE
        ) ELSE (
            SET "%1=!%1!!_doublequote!"
        )
    )
EXIT /B 0

:NOT_END_OF_LINE
    SET "%1=!TRUE!"
    IF "!%2!"=="!_newline!" (SET "%1=!FALSE!" & EXIT /B 0)
EXIT /B 0

:SKIP_COMMENT
    :: If we encounter a comment, skip the rest of the line
    IF "!%1:~0,1!"==";" (
        CALL :READ_WHILE _ %1 :NOT_END_OF_LINE
    )
EXIT /B 0

:TOKENIZER
    :: We put the input string into a buffer for reading
    SET "TOKENIZER_buffer=!%2!"
    CALL :VECTOR_NEW TOKENIZER_list
    SET "TOKENIZER_@=~@"

:TOKENIZER_LOOP
    CALL :READ_WHILE TOKENIZER_token TOKENIZER_buffer :IS_COMMA_OR_SPACE
    IF NOT "!TOKENIZER_token!"=="" (
        :: Whitespace and commas are ignored
        GOTO :TOKENIZER_LOOP
    )

    CALL :READ_STRING TOKENIZER_token TOKENIZER_buffer TOKENIZER_@
    IF NOT "!TOKENIZER_token!"=="" (
        CALL :VECTOR_PUSH TOKENIZER_list TOKENIZER_token
        GOTO :TOKENIZER_LOOP
    )

    CALL :READ_CHARACTER TOKENIZER_token TOKENIZER_buffer :IS_SPECIAL_CHARACTER
    IF NOT "!TOKENIZER_token!"=="" (
        CALL :VECTOR_PUSH TOKENIZER_list TOKENIZER_token
        GOTO :TOKENIZER_LOOP
    )

    CALL :READ_DOUBLEQUOTED_STRING TOKENIZER_token TOKENIZER_buffer
    IF NOT "!TOKENIZER_token!"=="" (
        CALL :VECTOR_PUSH TOKENIZER_list TOKENIZER_token
        GOTO :TOKENIZER_LOOP
    )

    IF "!TOKENIZER_buffer:~0,1!"==";" (
        :: If we encounter a comment, skip the rest of the line
        CALL :READ_WHILE _ TOKENIZER_buffer :NOT_END_OF_LINE
        GOTO :TOKENIZER_LOOP
    )

    CALL :READ_WHILE TOKENIZER_token TOKENIZER_buffer :IS_SYMBOL_CHARACTER
    IF NOT "!TOKENIZER_token!"=="" (
        CALL :VECTOR_PUSH TOKENIZER_list TOKENIZER_token
        GOTO :TOKENIZER_LOOP
    )

    SET "%1=!TOKENIZER_list!"
EXIT /B 0

:READ_LIST
    SET /a "READ_LIST_recursion_count+=1"

    SET /a "%3+=1"
    SET "%1=!EMPTY_LIST!"
    CALL :VECTOR_LENGTH READ_LIST_length %2
:READ_LIST_LOOP
    IF !%3! GEQ !READ_LIST_length! (
        SET /a "READ_LIST_recursion_count-=1"
        CALL :ABORT "expected ')', got EOF"
    )

    CALL :VECTOR_GET READ_LIST_token %2 %3
    IF "!READ_LIST_token!"==")" (
        SET /a "%3+=1"
        CALL :LIST_REVERSE tmp %1
        SET "%1=!tmp!"
        SET /a "READ_LIST_recursion_count-=1"
        EXIT /B 0
    )

    CALL :READ_FORM form%READ_LIST_recursion_count% %2 %3
    CALL :CONS %1 form%READ_LIST_recursion_count% %1

    GOTO :READ_LIST_LOOP
EXIT /B 0

:READ_VECTOR
    SET /a "READ_VECTOR_recursion_count+=1"

    SET /a "%3+=1"
    CALL :VECTOR_NEW %1
    CALL :VECTOR_LENGTH READ_LIST_length %2
:READ_VECTOR_LOOP
    IF !%3! GEQ !READ_LIST_length! (
        SET /a "READ_VECTOR_recursion_count-=1"
        CALL :ABORT "expected ']', got EOF"
    )

    CALL :VECTOR_GET READ_LIST_token %2 %3
    IF "!READ_LIST_token!"=="]" (
        SET /a "%3+=1"
        SET /a "READ_VECTOR_recursion_count-=1"
        EXIT /B 0
    )

    CALL :READ_FORM form%READ_VECTOR_recursion_count% %2 %3
    CALL :VECTOR_PUSH %1 form%READ_VECTOR_recursion_count%

    GOTO :READ_VECTOR_LOOP
EXIT /B 0

:IS_NUMERIC
    SET "%1=!FALSE!"
    IF "!%2:~0,1!"=="1" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,1!"=="2" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,1!"=="3" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,1!"=="4" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,1!"=="5" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,1!"=="6" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,1!"=="7" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,1!"=="8" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,1!"=="9" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,1!"=="0" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,2!"=="-1" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,2!"=="-2" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,2!"=="-3" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,2!"=="-4" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,2!"=="-5" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,2!"=="-6" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,2!"=="-7" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,2!"=="-8" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,2!"=="-9" (SET "%1=!TRUE!" & EXIT /B 0)
    IF "!%2:~0,2!"=="-0" (SET "%1=!TRUE!" & EXIT /B 0)
EXIT /B 0

:READ_ATOM
    CALL :VECTOR_GET READ_ATOM_token %2 %3
    CALL :SYMBOL_NEW %1 READ_ATOM_token
    SET /a "%3+=1"
EXIT /B 0

:READ_NUMBER
    CALL :VECTOR_GET READ_NUMBER_token %2 %3
    CALL :NUMBER_NEW %1 READ_NUMBER_token
    SET /a "%3+=1"
EXIT /B 0

:READ_HASHMAP
    SET /a "READ_HASHMAP_recursion_count+=1"

    CALL :HASHMAP_NEW %1
    SET /a "%3+=1"

:READ_HASHMAP_LOOP
    CALL :VECTOR_GET READ_HASHMAP_key%READ_HASHMAP_recursion_count% %2 %3
    SET /a "%3+=1"
    IF "!READ_HASHMAP_key%READ_HASHMAP_recursion_count%!"=="}" (
        SET /a "READ_HASHMAP_recursion_count-=1"
        EXIT /B 0
    )

    CALL :READ_FORM READ_HASHMAP_value%READ_HASHMAP_recursion_count% %2 %3

    CALL :HASHMAP_INSERT %1 READ_HASHMAP_key%READ_HASHMAP_recursion_count% READ_HASHMAP_value%READ_HASHMAP_recursion_count%

    GOTO :READ_HASHMAP_LOOP
EXIT /B 0

:READ_PREFIX
    SET /a "READ_PREFIX_recursion_count+=1"

    SET /a "%3+=1"

    SET "%1=!EMPTY_LIST!"
    CALL :SYMBOL_NEW READ_PREFIX_symbol%READ_PREFIX_recursion_count% %4
    CALL :READ_FORM READ_PREFIX_form%READ_PREFIX_recursion_count% %2 %3
    CALL :CONS %1 READ_PREFIX_form%READ_PREFIX_recursion_count% %1
    CALL :CONS %1 READ_PREFIX_symbol%READ_PREFIX_recursion_count% %1

    SET /a "READ_PREFIX_recursion_count-=1"
EXIT /B 0

:READ_PREFIX2
    SET /a "READ_PREFIX2_recursion_count+=1"

    SET /a "%3+=1"

    SET "%1=!EMPTY_LIST!"
    CALL :SYMBOL_NEW READ_PREFIX_symbol%READ_PREFIX2_recursion_count% %4
    CALL :READ_FORM READ_PREFIX_form%READ_PREFIX2_recursion_count% %2 %3
    CALL :READ_FORM READ_PREFIX_form2%READ_PREFIX2_recursion_count% %2 %3
    CALL :CONS %1 READ_PREFIX_form%READ_PREFIX2_recursion_count% %1
    CALL :CONS %1 READ_PREFIX_form2%READ_PREFIX2_recursion_count% %1
    CALL :CONS %1 READ_PREFIX_symbol%READ_PREFIX2_recursion_count% %1

    SET /a "READ_PREFIX2_recursion_count-=1"
EXIT /B 0

:READ_FORM
:: To get around the limitation of no local variables,
:: we keep a recursion count to diffirentiate variables
:: for each recursion level.

:: This can be solved better in the future by making them tail-recursive
    SET /a "READ_FORM_recursion_count+=1"
    CALL :VECTOR_LENGTH READ_FORM_length %2
    IF !%3! GEQ !READ_FORM_length! (
        CALL :ABORT "Unexpected EOF"
    )

    :: These IF statements slow down the reader significantly, can we
    :: branch some other way to make it faster?
    CALL :VECTOR_GET READ_FORM_token %2 %3
    IF "!READ_FORM_token!"=="(" (
        CALL :READ_LIST READ_FORM_form%READ_FORM_recursion_count% %2 %3
        GOTO :READ_FORM_EXIT
    )

    IF "!READ_FORM_token!"=="{" (
        CALL :READ_HASHMAP READ_FORM_form%READ_FORM_recursion_count% %2 %3
        GOTO :READ_FORM_EXIT
    )

    IF "!READ_FORM_token!"=="[" (
        CALL :READ_VECTOR READ_FORM_form%READ_FORM_recursion_count% %2 %3
        GOTO :READ_FORM_EXIT
    )

    IF "!READ_FORM_token!"=="!_singlequote!" (
        SET "READ_FORM_quote=quote"
        CALL :READ_PREFIX READ_FORM_form%READ_FORM_recursion_count% %2 %3 READ_FORM_quote
        GOTO :READ_FORM_EXIT
    )

    IF "!READ_FORM_token!"=="!_backtick!" (
        SET "READ_FORM_quote=quasiquote"
        CALL :READ_PREFIX READ_FORM_form%READ_FORM_recursion_count% %2 %3 READ_FORM_quote
        GOTO :READ_FORM_EXIT
    )

    IF "!READ_FORM_token!"=="!_tilde!" (
        SET "READ_FORM_quote=unquote"
        CALL :READ_PREFIX READ_FORM_form%READ_FORM_recursion_count% %2 %3 READ_FORM_quote
        GOTO :READ_FORM_EXIT
    )

    IF "!READ_FORM_token!"=="!_splice_unquote!" (
        SET "READ_FORM_quote=splice-unquote"
        CALL :READ_PREFIX READ_FORM_form%READ_FORM_recursion_count% %2 %3 READ_FORM_quote
        GOTO :READ_FORM_EXIT
    )

    IF "!READ_FORM_token!"=="@" (
        SET "READ_FORM_quote=deref"
        CALL :READ_PREFIX READ_FORM_form%READ_FORM_recursion_count% %2 %3 READ_FORM_quote
        GOTO :READ_FORM_EXIT
    )

    IF "!READ_FORM_token!"=="!_with_meta!" (
        SET "READ_FORM_quote=with-meta"
        CALL :READ_PREFIX2 READ_FORM_form%READ_FORM_recursion_count% %2 %3 READ_FORM_quote
        GOTO :READ_FORM_EXIT
    )

    CALL :IS_NUMERIC READ_FORM_is_numeric READ_FORM_token
    IF "!READ_FORM_is_numeric!"=="!TRUE!" (
        CALL :READ_NUMBER READ_FORM_form%READ_FORM_recursion_count% %2 %3
        GOTO :READ_FORM_EXIT
    )

    IF "!READ_FORM_token:~0,1!"=="!_doublequote!" (
        SET "READ_FORM_string_str=!READ_FORM_token:~1,-1!"
        CALL :STRING_NEW READ_FORM_form%READ_FORM_recursion_count% READ_FORM_string_str
        SET /a "%3+=1"
        GOTO :READ_FORM_EXIT
    )

    IF "!READ_FORM_token!"=="nil" (
        SET "READ_FORM_form%READ_FORM_recursion_count%=!NIL!"
        SET /a "%3+=1"
        GOTO :READ_FORM_EXIT
    )

    IF "!READ_FORM_token!"=="true" (
        SET "READ_FORM_form%READ_FORM_recursion_count%=!TRUE!"
        SET /a "%3+=1"
        GOTO :READ_FORM_EXIT
    )

    IF "!READ_FORM_token!"=="false" (
        SET "READ_FORM_form%READ_FORM_recursion_count%=!FALSE!"
        SET /a "%3+=1"
        GOTO :READ_FORM_EXIT
    )

    CALL :READ_ATOM READ_FORM_form%READ_FORM_recursion_count% %2 %3

:READ_FORM_EXIT
    SET "%1=!READ_FORM_form%READ_FORM_recursion_count%!"
    SET /a "READ_FORM_recursion_count-=1"
EXIT /B 0

:READ_STR
    CALL :TOKENIZER READ_STR_tokens %2
    SET "READ_STR_index=0"
    CALL :READ_FORM %1 READ_STR_tokens READ_STR_index
EXIT /B 0

:PR_STR
:: To get around the limitation of no local variables,
:: we keep a recursion count to diffirentiate variables
:: for each recursion level.

:: This can be solved better in the future by making them tail-recursive
    SET "PR_STR_recursion_count=0"
    CALL :_PR_STR %1 %2 %3
EXIT /B 0

:_PR_STR
    SET /a "PR_STR_recursion_count+=1"

    CALL :ERROR? PR_STR_is_error %2
    IF "!PR_STR_is_error!"=="!TRUE!" (
        CALL :ERROR_TO_STR %1 %2
        SET "%1=Error: !%1!"
        SET /a "PR_STR_recursion_count-=1"
        EXIT /B 0
    )

    CALL :SYMBOL? PR_STR_is_symbol %2
    IF "!PR_STR_is_symbol!"=="!TRUE!" (
        CALL :SYMBOL_TO_STR %1 %2
        SET /a "PR_STR_recursion_count-=1"
        EXIT /B 0
    )

    CALL :ATOM? PR_STR_is_atom %2
    IF "!PR_STR_is_atom!"=="!TRUE!" (
        CALL :ATOM_DEREF _PR_STR_ast%PR_STR_recursion_count% %2
        CALL :_PR_STR _PR_STR_str%PR_STR_recursion_count% _PR_STR_ast%PR_STR_recursion_count%
        SET "%1=(symbol !_PR_STR_str%PR_STR_recursion_count%!)"
        SET /a "PR_STR_recursion_count-=1"
        EXIT /B 0
    )

    CALL :NUMBER? PR_STR_is_number %2
    IF "!PR_STR_is_number!"=="!TRUE!" (
        CALL :NUMBER_TO_STR %1 %2
        SET /a "PR_STR_recursion_count-=1"
        EXIT /B 0
    )

    CALL :STRING? PR_STR_is_string %2
    IF "!PR_STR_is_string!"=="!TRUE!" (
        CALL :STRING_TO_STR PR_STR_string %2
        IF "!%3!"=="!TRUE!" (
            CALL :STRING_REPLACE_CHAR PR_STR_string PR_STR_string _backslash _backslash_escape
            CALL :STRING_REPLACE_CHAR PR_STR_string PR_STR_string _newline _newline_escape
            CALL :STRING_REPLACE_CHAR PR_STR_string PR_STR_string _doublequote _doublequote_escape
            SET "%1=!_doublequote!!PR_STR_string!!_doublequote!"
        ) ELSE (
            SET "%1=!PR_STR_string!"
        )
        SET /a "PR_STR_recursion_count-=1"
        EXIT /B 0
    )

    CALL :FUNCTION? PR_STR_is_function %2
    IF "!PR_STR_is_function!"=="!TRUE!" (
        SET "%1=#<function>"
        SET /a "PR_STR_recursion_count-=1"
        EXIT /B 0
    )

    IF "!%2!"=="!NIL!" (
        SET "%1=nil"
        SET /a "PR_STR_recursion_count-=1"
        EXIT /B 0
    )

    IF "!%2!"=="!EMPTY_LIST!" (
        SET "%1=()"
        SET /a "PR_STR_recursion_count-=1"
        EXIT /B 0
    )

    IF "!%2!"=="!TRUE!" (
        SET "%1=true"
        SET /a "PR_STR_recursion_count-=1"
        EXIT /B 0
    )

    IF "!%2!"=="!FALSE!" (
        SET "%1=false"
        SET /a "PR_STR_recursion_count-=1"
        EXIT /B 0
    )

    CALL :LIST? PR_STR_is_list %2
    IF "!PR_STR_is_list!"=="!TRUE!" (
        SET "%1=("
        SET "_PR_STR_tail%PR_STR_recursion_count%=!%2!"
:_PR_STR_LIST_LOOP
        CALL :LIST_EMPTY? _PR_STR_is_empty _PR_STR_tail%PR_STR_recursion_count%
        IF "!_PR_STR_is_empty!"=="!FALSE!" (
            CALL :FIRST _PR_STR_form _PR_STR_tail%PR_STR_recursion_count%
            CALL :REST _PR_STR_tail%PR_STR_recursion_count% _PR_STR_tail%PR_STR_recursion_count%

            CALL :_PR_STR PR_STR_str%PR_STR_recursion_count% _PR_STR_form %3

            SET "%1=!%1!!PR_STR_str%PR_STR_recursion_count%!"
            CALL :LIST_EMPTY? _PR_STR_is_empty _PR_STR_tail%PR_STR_recursion_count%
            IF "!_PR_STR_is_empty!"=="!FALSE!" (
                SET "%1=!%1! "
            )
            GOTO :_PR_STR_LIST_LOOP
        )

        SET "%1=!%1!)"
        SET /a "PR_STR_recursion_count-=1"
        EXIT /B 0
    )

    CALL :VECTOR? PR_STR_is_vector %2
    IF "!PR_STR_is_vector!"=="!TRUE!" (
        CALL :VECTOR_LENGTH PR_STR_length %2
        SET /a "PR_STR_length-=1"
        SET "%1=["
        FOR /L %%G IN (0, 1, !PR_STR_length!) DO (
            SET "PR_STR_index=%%G"
            CALL :VECTOR_GET PR_STR_item%PR_STR_recursion_count% %2 PR_STR_index
            CALL :_PR_STR PR_STR_str%PR_STR_recursion_count% PR_STR_item%PR_STR_recursion_count% %3
            IF %%G NEQ 0 (
                SET "%1=!%1! "
            )
            SET "%1=!%1!!PR_STR_str%PR_STR_recursion_count%!"
        )
        SET "%1=!%1!]"

        SET /a "PR_STR_recursion_count-=1"
        EXIT /B 0
    )

    CALL :HASHMAP? PR_STR_is_hashmap %2
    IF "!PR_STR_is_hashmap!"=="!TRUE!" (
        CALL :HASHMAP_KEYS PR_STR_keys%PR_STR_recursion_count% %2
        CALL :VECTOR_LENGTH PR_STR_length PR_STR_keys%PR_STR_recursion_count%
        SET /a "PR_STR_length-=1"
        SET "%1={"
        FOR /L %%G IN (0, 1, !PR_STR_length!) DO (
            SET "PR_STR_index=%%G"
            CALL :VECTOR_GET PR_STR_key%PR_STR_recursion_count% PR_STR_keys%PR_STR_recursion_count% PR_STR_index
            CALL :HASHMAP_GET PR_STR_value%PR_STR_recursion_count% %2 PR_STR_key%PR_STR_recursion_count%
            CALL :_PR_STR PR_STR_str%PR_STR_recursion_count% PR_STR_value%PR_STR_recursion_count% %3
            IF %%G NEQ 0 (
                SET "%1=!%1! "
            )
            SET "%1=!%1!!PR_STR_key%PR_STR_recursion_count%! !PR_STR_str%PR_STR_recursion_count%!"
        )
        SET "%1=!%1!}"

        SET /a "PR_STR_recursion_count-=1"
        EXIT /B 0
    )

    echo !%2!
    CALL :ABORT "Unexpected type !%2:~0,1!"
EXIT /B 0

:ENV_NEW
    SET /a "_env_counter+=1"
    SET "_env_outer!_env_counter!=!NIL!"
    CALL :HASHMAP_NEW _env_data!_env_counter!
    SET "%1=E!_env_counter!"
EXIT /B 0

:ENV_SET_OUTER
    SET "ENV_SET_id=!%1:~1,8191!"
    SET "_env_outer!ENV_SET_id!=!%2!"
EXIT /B 0

:ENV_SET
    SET "ENV_SET_id=!%1:~1,8191!"
    CALL :SYMBOL_TO_STR ENV_SET_key %2
    CALL :HASHMAP_INSERT _env_data!ENV_SET_id! ENV_SET_key %3
EXIT /B 0

:ENV_GET
    SET "ENV_GET_id=!%2:~1,8191!"
    CALL :SYMBOL_TO_STR ENV_GET_key %3
    CALL :HASHMAP_GET %1 _env_data!ENV_GET_id! ENV_GET_key
    IF "!%1!"=="!NIL!" (
        IF NOT "!_env_outer%ENV_GET_id%!"=="!NIL!" (
            CALL :ENV_GET %1 _env_outer%ENV_GET_id% %3
        )
    )
EXIT /B 0

:ARGS_OR_ERROR
    CALL :CALL_STACK_POP ARGS_OR_ERROR_args
    CALL :LIST_COUNT ARGS_OR_ERROR_size ARGS_OR_ERROR_args
    IF NOT "!ARGS_OR_ERROR_size!"=="%2" (
        SET "ARGS_OR_ERROR_error_message=Wrong number of arguments: got !ARGS_OR_ERROR_size! expected %2!"
        CALL :ERROR_NEW %1 ARGS_OR_ERROR_error_message
    ) ELSE (
        SET "%1=!ARGS_OR_ERROR_args!"
    )
EXIT /B 0

:MAL_CONS
    CALL :ARGS_OR_ERROR MAL_CONS_args 2
    CALL :ERROR? MAL_CONS_args_is_error MAL_CONS_args
    IF "!MAL_CONS_args_is_error!"=="!TRUE!" (
        CALL :CALL_STACK_PUSH MAL_CONS_args
        EXIT /B 0
    )

    CALL :FIRST MAL_CONS_first MAL_CONS_args
    CALL :REST MAL_CONS_args MAL_CONS_args
    CALL :FIRST MAL_CONS_second MAL_CONS_args

    CALL :VECTOR? MAL_CONS_is_vector MAL_CONS_second
    IF "!MAL_CONS_is_vector!"=="!TRUE!" (
        CALL :VECTOR_TO_LIST MAL_CONS_second MAL_CONS_second
    )

    CALL :CONS MAL_CONS_list MAL_CONS_first MAL_CONS_second

    CALL :CALL_STACK_PUSH MAL_CONS_list
EXIT /B 0

:MAL_NUMBER_ADD
    CALL :ARGS_OR_ERROR MAL_NUMBER_ADD_args 2
    CALL :ERROR? MAL_NUMBER_ADD_args_is_error MAL_NUMBER_ADD_args
    IF "!MAL_NUMBER_ADD_args_is_error!"=="!TRUE!" (
        CALL :CALL_STACK_PUSH MAL_NUMBER_ADD_args
        EXIT /B 0
    )

    CALL :FIRST MAL_NUMBER_ADD_first MAL_NUMBER_ADD_args
    CALL :REST MAL_NUMBER_ADD_args MAL_NUMBER_ADD_args
    CALL :FIRST MAL_NUMBER_ADD_second MAL_NUMBER_ADD_args
    CALL :NUMBER_TO_STR MAL_NUMBER_ADD_first_str MAL_NUMBER_ADD_first
    CALL :NUMBER_TO_STR MAL_NUMBER_ADD_second_str MAL_NUMBER_ADD_second
    SET /a "MAL_NUMBER_ADD_value_str=!MAL_NUMBER_ADD_first_str!+!MAL_NUMBER_ADD_second_str!"
    CALL :NUMBER_NEW MAL_NUMBER_ADD_value MAL_NUMBER_ADD_value_str
    CALL :CALL_STACK_PUSH MAL_NUMBER_ADD_value
EXIT /B 0

:MAL_NUMBER_SUBTRACT
    CALL :ARGS_OR_ERROR MAL_NUMBER_SUBTRACT_args 2
    CALL :ERROR? MAL_NUMBER_SUBTRACT_args_is_error MAL_NUMBER_SUBTRACT_args
    IF "!MAL_NUMBER_SUBTRACT_args_is_error!"=="!TRUE!" (
        CALL :CALL_STACK_PUSH MAL_NUMBER_SUBTRACT_args
        EXIT /B 0
    )

    CALL :FIRST MAL_NUMBER_SUBTRACT_first MAL_NUMBER_SUBTRACT_args
    CALL :REST MAL_NUMBER_SUBTRACT_args MAL_NUMBER_SUBTRACT_args
    CALL :FIRST MAL_NUMBER_SUBTRACT_second MAL_NUMBER_SUBTRACT_args
    CALL :NUMBER_TO_STR MAL_NUMBER_SUBTRACT_first_str MAL_NUMBER_SUBTRACT_first
    CALL :NUMBER_TO_STR MAL_NUMBER_SUBTRACT_second_str MAL_NUMBER_SUBTRACT_second
    SET /a "MAL_NUMBER_SUBTRACT_value_str=!MAL_NUMBER_SUBTRACT_first_str!-!MAL_NUMBER_SUBTRACT_second_str!"
    CALL :NUMBER_NEW MAL_NUMBER_SUBTRACT_value MAL_NUMBER_SUBTRACT_value_str
    CALL :CALL_STACK_PUSH MAL_NUMBER_SUBTRACT_value
EXIT /B 0

:MAL_NUMBER_MULTIPLY
    CALL :ARGS_OR_ERROR MAL_NUMBER_MULTIPLY_args 2
    CALL :ERROR? MAL_NUMBER_MULTIPLY_args_is_error MAL_NUMBER_MULTIPLY_args
    IF "!MAL_NUMBER_MULTIPLY_args_is_error!"=="!TRUE!" (
        CALL :CALL_STACK_PUSH MAL_NUMBER_MULTIPLY_args
        EXIT /B 0
    )

    CALL :FIRST MAL_NUMBER_MULTIPLY_first MAL_NUMBER_MULTIPLY_args
    CALL :REST MAL_NUMBER_MULTIPLY_args MAL_NUMBER_MULTIPLY_args
    CALL :FIRST MAL_NUMBER_MULTIPLY_second MAL_NUMBER_MULTIPLY_args
    CALL :NUMBER_TO_STR MAL_NUMBER_MULTIPLY_first_str MAL_NUMBER_MULTIPLY_first
    CALL :NUMBER_TO_STR MAL_NUMBER_MULTIPLY_second_str MAL_NUMBER_MULTIPLY_second
    SET /a "MAL_NUMBER_MULTIPLY_value_str=!MAL_NUMBER_MULTIPLY_first_str!*!MAL_NUMBER_MULTIPLY_second_str!"
    CALL :NUMBER_NEW MAL_NUMBER_MULTIPLY_value MAL_NUMBER_MULTIPLY_value_str
    CALL :CALL_STACK_PUSH MAL_NUMBER_MULTIPLY_value
EXIT /B 0

:MAL_NUMBER_DIVIDE
    CALL :ARGS_OR_ERROR MAL_NUMBER_DIVIDE_args 2
    CALL :ERROR? MAL_NUMBER_DIVIDE_args_is_error MAL_NUMBER_DIVIDE_args
    IF "!MAL_NUMBER_DIVIDE_args_is_error!"=="!TRUE!" (
        CALL :CALL_STACK_PUSH MAL_NUMBER_DIVIDE_args
        EXIT /B 0
    )

    CALL :FIRST MAL_NUMBER_DIVIDE_first MAL_NUMBER_DIVIDE_args
    CALL :REST MAL_NUMBER_DIVIDE_args MAL_NUMBER_DIVIDE_args
    CALL :FIRST MAL_NUMBER_DIVIDE_second MAL_NUMBER_DIVIDE_args
    CALL :NUMBER_TO_STR MAL_NUMBER_DIVIDE_first_str MAL_NUMBER_DIVIDE_first
    CALL :NUMBER_TO_STR MAL_NUMBER_DIVIDE_second_str MAL_NUMBER_DIVIDE_second
    SET /a "MAL_NUMBER_DIVIDE_value_str=!MAL_NUMBER_DIVIDE_first_str!/!MAL_NUMBER_DIVIDE_second_str!"
    CALL :NUMBER_NEW MAL_NUMBER_DIVIDE_value MAL_NUMBER_DIVIDE_value_str
    CALL :CALL_STACK_PUSH MAL_NUMBER_DIVIDE_value
EXIT /B 0

:MAL_STR
    SET "MAL_STR_str="
    CALL :CALL_STACK_POP MAL_STR_args

:_MAL_STR_LOOP
    IF NOT "!MAL_STR_args!"=="!EMPTY_LIST!" (
        CALL :FIRST MAL_STR_argument MAL_STR_args
        CALL :REST MAL_STR_args MAL_STR_args

        CALL :PR_STR MAL_STR_substring MAL_STR_argument FALSE
        SET "MAL_STR_str=!MAL_STR_str!!MAL_STR_substring!"
        GOTO :_MAL_STR_LOOP
    )

    CALL :STRING_NEW MAL_STR_string MAL_STR_str
    CALL :CALL_STACK_PUSH MAL_STR_string
EXIT /B 0

:_MAL_PR_STR
    SET "_MAL_PR_STR_str="
    CALL :CALL_STACK_POP _MAL_PR_STR_args

:_MAL_PR_STR_LOOP
    IF NOT "!_MAL_PR_STR_args!"=="!EMPTY_LIST!" (
        CALL :FIRST _MAL_PR_STR_argument _MAL_PR_STR_args
        CALL :REST _MAL_PR_STR_args _MAL_PR_STR_args

        CALL :PR_STR _MAL_PR_STR_substring _MAL_PR_STR_argument %1
        SET "_MAL_PR_STR_str=!_MAL_PR_STR_str! !_MAL_PR_STR_substring!"
        GOTO :_MAL_PR_STR_LOOP
    )

    IF NOT "!_MAL_PR_STR_str!"=="" (
        SET "_MAL_PR_STR_str=!_MAL_PR_STR_str:~1!"
    )
    CALL :STRING_NEW _MAL_PR_STR_string _MAL_PR_STR_str
    CALL :CALL_STACK_PUSH _MAL_PR_STR_string
EXIT /B 0

:MAL_PR_STR
    CALL :_MAL_PR_STR TRUE
EXIT /B 0

:MAL_PRN
    CALL :_MAL_PR_STR TRUE
    CALL :CALL_STACK_POP MAL_PRN_string
    CALL :STRING_TO_STR MAL_PRN_str MAL_PRN_string
    CALL :ECHO MAL_PRN_str
    CALL :CALL_STACK_PUSH NIL
EXIT /B 0

:MAL_PRINTLN
    CALL :_MAL_PR_STR FALSE
    CALL :CALL_STACK_POP MAL_PRINTLN_string
    CALL :STRING_TO_STR MAL_PRINTLN_str MAL_PRINTLN_string
    CALL :ECHO MAL_PRINTLN_str
    CALL :CALL_STACK_PUSH NIL
EXIT /B 0

:MAL_LIST?
    CALL :ARGS_OR_ERROR MAL_LIST?_args 1
    CALL :ERROR? MAL_LIST?_args_is_error MAL_LIST?_args
    IF "!MAL_LIST?_args_is_error!"=="!TRUE!" (
        CALL :CALL_STACK_PUSH MAL_LIST?_args
        EXIT /B 0
    )

    CALL :FIRST MAL_LIST?_first MAL_LIST?_args
    CALL :LIST? MAL_LIST?_is_list MAL_LIST?_first
    CALL :CALL_STACK_PUSH MAL_LIST?_is_list
EXIT /B 0

:MAL_EMPTY?
    CALL :ARGS_OR_ERROR MAL_EMPTY?_args 1
    CALL :ERROR? MAL_EMPTY?_args_is_error MAL_EMPTY?_args
    IF "!MAL_EMPTY?_args_is_error!"=="!TRUE!" (
        CALL :CALL_STACK_PUSH MAL_EMPTY?_args
        EXIT /B 0
    )

    CALL :FIRST MAL_EMPTY?_first MAL_EMPTY?_args
    CALL :VECTOR? MAL_EMPTY?_is_vector MAL_EMPTY?_first
    IF "!MAL_EMPTY?_is_vector!"=="!TRUE!" (
        CALL :VECTOR_EMPTY? MAL_EMPTY?_is_empty MAL_EMPTY?_first
    ) ELSE (
        CALL :LIST_EMPTY? MAL_EMPTY?_is_empty MAL_EMPTY?_first
    )
    CALL :CALL_STACK_PUSH MAL_EMPTY?_is_empty
EXIT /B 0

:MAL_COUNT
    CALL :ARGS_OR_ERROR MAL_COUNT_args 1
    CALL :ERROR? MAL_COUNT_args_is_error MAL_COUNT_args
    IF "!MAL_COUNT_args_is_error!"=="!TRUE!" (
        CALL :CALL_STACK_PUSH MAL_COUNT_args
        EXIT /B 0
    )

    CALL :FIRST MAL_COUNT_first MAL_COUNT_args
    CALL :VECTOR? MAL_COUNT_is_vector MAL_COUNT_first
    IF "!MAL_COUNT_is_vector!"=="!TRUE!" (
        CALL :VECTOR_LENGTH MAL_COUNT_count MAL_COUNT_first
    ) ELSE (
        CALL :LIST_COUNT MAL_COUNT_count MAL_COUNT_first
    )
    CALL :NUMBER_NEW MAL_COUNT_count_number MAL_COUNT_count
    CALL :CALL_STACK_PUSH MAL_COUNT_count_number
EXIT /B 0

:MAL_GREATER_THAN
    CALL :ARGS_OR_ERROR MAL_GREATER_THAN_args 2
    CALL :ERROR? MAL_GREATER_THAN_args_is_error MAL_GREATER_THAN_args
    IF "!MAL_GREATER_THAN_args_is_error!"=="!TRUE!" (
        CALL :CALL_STACK_PUSH MAL_GREATER_THAN_args
        EXIT /B 0
    )

    CALL :FIRST MAL_GREATER_THAN_first MAL_GREATER_THAN_args
    CALL :REST MAL_GREATER_THAN_args MAL_GREATER_THAN_args
    CALL :FIRST MAL_GREATER_THAN_second MAL_GREATER_THAN_args
    CALL :NUMBER_TO_STR MAL_GREATER_THAN_first_str MAL_GREATER_THAN_first
    CALL :NUMBER_TO_STR MAL_GREATER_THAN_second_str MAL_GREATER_THAN_second
    IF !MAL_GREATER_THAN_first_str! GTR !MAL_GREATER_THAN_second_str! (
        CALL :CALL_STACK_PUSH TRUE
    ) ELSE (
        CALL :CALL_STACK_PUSH FALSE
    )
EXIT /B 0

:MAL_LOWER_THAN
    CALL :ARGS_OR_ERROR MAL_LOWER_THAN_args 2
    CALL :ERROR? MAL_LOWER_THAN_args_is_error MAL_LOWER_THAN_args
    IF "!MAL_LOWER_THAN_args_is_error!"=="!TRUE!" (
        CALL :CALL_STACK_PUSH MAL_LOWER_THAN_args
        EXIT /B 0
    )

    CALL :FIRST MAL_LOWER_THAN_first MAL_LOWER_THAN_args
    CALL :REST MAL_LOWER_THAN_args MAL_LOWER_THAN_args
    CALL :FIRST MAL_LOWER_THAN_second MAL_LOWER_THAN_args
    CALL :NUMBER_TO_STR MAL_LOWER_THAN_first_str MAL_LOWER_THAN_first
    CALL :NUMBER_TO_STR MAL_LOWER_THAN_second_str MAL_LOWER_THAN_second
    IF !MAL_LOWER_THAN_first_str! LSS !MAL_LOWER_THAN_second_str! (
        CALL :CALL_STACK_PUSH TRUE
    ) ELSE (
        CALL :CALL_STACK_PUSH FALSE
    )
EXIT /B 0

:MAL_GREATER_THAN_OR_EQUAL
    CALL :ARGS_OR_ERROR MAL_GREATER_THAN_OR_EQUAL_args 2
    CALL :ERROR? MAL_GREATER_THAN_OR_EQUAL_args_is_error MAL_GREATER_THAN_OR_EQUAL_args
    IF "!MAL_GREATER_THAN_OR_EQUAL_args_is_error!"=="!TRUE!" (
        CALL :CALL_STACK_PUSH MAL_GREATER_THAN_OR_EQUAL_args
        EXIT /B 0
    )

    CALL :FIRST MAL_GREATER_THAN_OR_EQUAL_first MAL_GREATER_THAN_OR_EQUAL_args
    CALL :REST MAL_GREATER_THAN_OR_EQUAL_args MAL_GREATER_THAN_OR_EQUAL_args
    CALL :FIRST MAL_GREATER_THAN_OR_EQUAL_second MAL_GREATER_THAN_OR_EQUAL_args
    CALL :NUMBER_TO_STR MAL_GREATER_THAN_OR_EQUAL_first_str MAL_GREATER_THAN_OR_EQUAL_first
    CALL :NUMBER_TO_STR MAL_GREATER_THAN_OR_EQUAL_second_str MAL_GREATER_THAN_OR_EQUAL_second
    IF !MAL_GREATER_THAN_OR_EQUAL_first_str! GEQ !MAL_GREATER_THAN_OR_EQUAL_second_str! (
        CALL :CALL_STACK_PUSH TRUE
    ) ELSE (
        CALL :CALL_STACK_PUSH FALSE
    )
EXIT /B 0

:MAL_LOWER_THAN_OR_EQUAL
    CALL :ARGS_OR_ERROR MAL_LOWER_THAN_OR_EQUAL_args 2
    CALL :ERROR? MAL_LOWER_THAN_OR_EQUAL_args_is_error MAL_LOWER_THAN_OR_EQUAL_args
    IF "!MAL_LOWER_THAN_OR_EQUAL_args_is_error!"=="!TRUE!" (
        CALL :CALL_STACK_PUSH MAL_LOWER_THAN_OR_EQUAL_args
        EXIT /B 0
    )

    CALL :FIRST MAL_LOWER_THAN_OR_EQUAL_first MAL_LOWER_THAN_OR_EQUAL_args
    CALL :REST MAL_LOWER_THAN_OR_EQUAL_args MAL_LOWER_THAN_OR_EQUAL_args
    CALL :FIRST MAL_LOWER_THAN_OR_EQUAL_second MAL_LOWER_THAN_OR_EQUAL_args
    CALL :NUMBER_TO_STR MAL_LOWER_THAN_OR_EQUAL_first_str MAL_LOWER_THAN_OR_EQUAL_first
    CALL :NUMBER_TO_STR MAL_LOWER_THAN_OR_EQUAL_second_str MAL_LOWER_THAN_OR_EQUAL_second
    IF !MAL_LOWER_THAN_OR_EQUAL_first_str! LEQ !MAL_LOWER_THAN_OR_EQUAL_second_str! (
        CALL :CALL_STACK_PUSH TRUE
    ) ELSE (
        CALL :CALL_STACK_PUSH FALSE
    )
EXIT /B 0

:MAL_EQUAL
    CALL :ARGS_OR_ERROR MAL_EQUAL_args 2
    CALL :ERROR? MAL_EQUAL_args_is_error MAL_EQUAL_args
    IF "!MAL_EQUAL_args_is_error!"=="!TRUE!" (
        CALL :CALL_STACK_PUSH MAL_EQUAL_args
        EXIT /B 0
    )

    CALL :FIRST MAL_EQUAL_first MAL_EQUAL_args
    CALL :REST MAL_EQUAL_args MAL_EQUAL_args
    CALL :FIRST MAL_EQUAL_second MAL_EQUAL_args
    CALL :EQUAL? MAL_EQUAL_result MAL_EQUAL_first MAL_EQUAL_second
    CALL :CALL_STACK_PUSH MAL_EQUAL_result
EXIT /B 0

:MAL_LIST
EXIT /B 0

:MAL_READ_STRING
    CALL :ARGS_OR_ERROR MAL_READ_STRING_args 1
    CALL :ERROR? MAL_READ_STRING_args_is_error MAL_READ_STRING_args
    IF "!MAL_READ_STRING_args_is_error!"=="!TRUE!" (
        CALL :CALL_STACK_PUSH MAL_READ_STRING_args
        EXIT /B 0
    )

    CALL :FIRST MAL_READ_STRING_first MAL_READ_STRING_args
    CALL :STRING_TO_STR MAL_READ_STRING_str MAL_READ_STRING_first
    CALL :READ_STR MAL_READ_STRING_result MAL_READ_STRING_str
    CALL :CALL_STACK_PUSH MAL_READ_STRING_result
EXIT /B 0

:MAL_EVAL
    CALL :ARGS_OR_ERROR MAL_EVAL_args 1
    CALL :ERROR? MAL_EVAL_args_is_error MAL_EVAL_args
    IF "!MAL_EVAL_args_is_error!"=="!TRUE!" (
        CALL :CALL_STACK_PUSH MAL_EVAL_args
        EXIT /B 0
    )

    CALL :FIRST MAL_EVAL_first MAL_EVAL_args
    CALL :EVAL MAL_EVAL_result MAL_EVAL_first REPL_env
    CALL :CALL_STACK_PUSH MAL_EVAL_result
EXIT /B 0

:MAL_SLURP
    CALL :ARGS_OR_ERROR MAL_SLURP_args 1
    CALL :ERROR? MAL_SLURP_args_is_error MAL_SLURP_args
    IF "!MAL_SLURP_args_is_error!"=="!TRUE!" (
        CALL :CALL_STACK_PUSH MAL_SLURP_args
        EXIT /B 0
    )

    CALL :FIRST MAL_SLURP_first MAL_SLURP_args
    CALL :STRING_TO_STR MAL_SLURP_filename MAL_SLURP_first
    SET "MAL_SLURP_filename=!MAL_SLURP_filename:^/=^\!"
    SET "MAL_SLURP_str="

    for /f "delims=" %%n in ('cmd /c C:\Windows\System32\find.exe /C /V "" %MAL_SLURP_filename%') do set "len=%%n"
    set "len=!len:*: =!"

    <%MAL_SLURP_filename% (
      for /l %%l in (1 1 !len!) do (
        set "line="
        set /p "line="
        set "MAL_SLURP_str=!MAL_SLURP_str!!line!!_newline!"
      )
    )

    CALL :STRING_NEW MAL_SLURP_string MAL_SLURP_str
    CALL :CALL_STACK_PUSH MAL_SLURP_string
EXIT /B 0


:MAL_ATOM
    CALL :ARGS_OR_ERROR MAL_ATOM_args 1
    CALL :ERROR? MAL_ATOM_args_is_error MAL_ATOM_args
    IF "!MAL_ATOM_args_is_error!"=="!TRUE!" (
        CALL :CALL_STACK_PUSH MAL_ATOM_args
        EXIT /B 0
    )

    CALL :FIRST MAL_ATOM_first MAL_ATOM_args
    CALL :ATOM_NEW MAL_ATOM_result MAL_ATOM_first
    CALL :CALL_STACK_PUSH MAL_ATOM_result
EXIT /B 0

:MAL_ATOM?
    CALL :ARGS_OR_ERROR MAL_ATOM?_args 1
    CALL :ERROR? MAL_ATOM?_args_is_error MAL_ATOM?_args
    IF "!MAL_ATOM?_args_is_error!"=="!TRUE!" (
        CALL :CALL_STACK_PUSH MAL_ATOM?_args
        EXIT /B 0
    )

    CALL :FIRST MAL_ATOM?_first MAL_ATOM?_args
    CALL :ATOM? MAL_ATOM?_result MAL_ATOM?_first
    CALL :CALL_STACK_PUSH MAL_ATOM?_result
EXIT /B 0

:MAL_ATOM_DEREF
    CALL :ARGS_OR_ERROR MAL_ATOM_DEREF_args 1
    CALL :ERROR? MAL_ATOM_DEREF_args_is_error MAL_ATOM_DEREF_args
    IF "!MAL_ATOM_DEREF_args_is_error!"=="!TRUE!" (
        CALL :CALL_STACK_PUSH MAL_ATOM_DEREF_args
        EXIT /B 0
    )

    CALL :FIRST MAL_ATOM_DEREF_first MAL_ATOM_DEREF_args
    CALL :ATOM_DEREF MAL_ATOM_DEREF_result MAL_ATOM_DEREF_first
    CALL :CALL_STACK_PUSH MAL_ATOM_DEREF_result
EXIT /B 0

:MAL_ATOM_RESET
    CALL :ARGS_OR_ERROR MAL_ATOM_RESET_args 2
    CALL :ERROR? MAL_ATOM_RESET_args_is_error MAL_ATOM_RESET_args
    IF "!MAL_ATOM_RESET_args_is_error!"=="!TRUE!" (
        CALL :CALL_STACK_PUSH MAL_ATOM_RESET_args
        EXIT /B 0
    )

    CALL :FIRST MAL_ATOM_RESET_first MAL_ATOM_RESET_args
    CALL :REST MAL_ATOM_RESET_args MAL_ATOM_RESET_args
    CALL :FIRST MAL_ATOM_RESET_second MAL_ATOM_RESET_args
    CALL :ATOM_RESET MAL_ATOM_RESET_result MAL_ATOM_RESET_first MAL_ATOM_RESET_second
    CALL :CALL_STACK_PUSH MAL_ATOM_RESET_result
EXIT /B 0

:MAL_CONCAT
    SET "MAL_CONCAT_list=!EMPTY_LIST!"
    CALL :CALL_STACK_POP MAL_CONCAT_args
:MAL_CONCAT_RECUR
    IF "!MAL_CONCAT_args!"=="!EMPTY_LIST!" (
        CALL :CALL_STACK_PUSH MAL_CONCAT_list
        EXIT /B 0
    )

    CALL :FIRST MAL_CONCAT_partial_list MAL_CONCAT_args
    CALL :REST MAL_CONCAT_args MAL_CONCAT_args

    CALL :LIST_CONCAT MAL_CONCAT_list MAL_CONCAT_list MAL_CONCAT_partial_list
    GOTO :MAL_CONCAT_RECUR
EXIT /B 0

:DEFINE_FUN
    CALL :FUNCTION_NEW DEFINE_FUN_value %3 NIL NIL NIL
    CALL :SYMBOL_NEW DEFINE_FUN_key %2
    CALL :ENV_SET %1 DEFINE_FUN_key DEFINE_FUN_value
EXIT /B 0

:START

CALL :ENV_NEW REPL_env
CALL :DEFINE_FUN REPL_env _plus :MAL_NUMBER_ADD
CALL :DEFINE_FUN REPL_env _minus :MAL_NUMBER_SUBTRACT
CALL :DEFINE_FUN REPL_env _asterisk :MAL_NUMBER_MULTIPLY
CALL :DEFINE_FUN REPL_env _slash :MAL_NUMBER_DIVIDE
CALL :DEFINE_FUN REPL_env _greater_than :MAL_GREATER_THAN
CALL :DEFINE_FUN REPL_env _lower_than :MAL_LOWER_THAN
CALL :DEFINE_FUN REPL_env _greater_than_equal :MAL_GREATER_THAN_OR_EQUAL
CALL :DEFINE_FUN REPL_env _lower_than_equal :MAL_LOWER_THAN_OR_EQUAL
CALL :DEFINE_FUN REPL_env _equal :MAL_EQUAL

SET "_name=cons"
CALL :DEFINE_FUN REPL_env _name :MAL_CONS
SET "_name=concat"
CALL :DEFINE_FUN REPL_env _name :MAL_CONCAT
SET "_name=str"
CALL :DEFINE_FUN REPL_env _name :MAL_STR
SET "_name=prn"
CALL :DEFINE_FUN REPL_env _name :MAL_PRN
SET "_name=pr-str"
CALL :DEFINE_FUN REPL_env _name :MAL_PR_STR
SET "_name=println"
CALL :DEFINE_FUN REPL_env _name :MAL_PRINTLN
SET "_name=list"
CALL :DEFINE_FUN REPL_env _name :MAL_LIST
SET "_name=list?"
CALL :DEFINE_FUN REPL_env _name :MAL_LIST?
SET "_name=empty?"
CALL :DEFINE_FUN REPL_env _name :MAL_EMPTY?
SET "_name=count"
CALL :DEFINE_FUN REPL_env _name :MAL_COUNT
SET "_name=read-string"
CALL :DEFINE_FUN REPL_env _name :MAL_READ_STRING
SET "_name=eval"
CALL :DEFINE_FUN REPL_env _name :MAL_EVAL
SET "_name=slurp"
CALL :DEFINE_FUN REPL_env _name :MAL_SLURP
SET "_name=symbol"
CALL :DEFINE_FUN REPL_env _name :MAL_ATOM
SET "_name=symbol?"
CALL :DEFINE_FUN REPL_env _name :MAL_ATOM?
SET "_name=deref"
CALL :DEFINE_FUN REPL_env _name :MAL_ATOM_DEREF
SET "_name=reset^!"
CALL :DEFINE_FUN REPL_env _name :MAL_ATOM_RESET

SET "_script=(def^! not (fn* (a) (if a false true)))"
CALL :REP _ _script REPL_env
SET "_script=(def^! load-file (fn* (f) (eval (read-string (str ^"(do ^" (slurp f) ^")^")))))"
CALL :REP _ _script REPL_env
SET "_script=(def^! swap^! (fn* (a f & more) (reset^! a (eval (cons f (cons (deref a) more))))))"
CALL :REP _ _script REPL_env

SET "argv=!EMPTY_LIST!"
SET "argv_key=!_asterisk!ARGV!_asterisk!"
SET "arg=!%5!"
IF NOT "!arg!"=="" CALL :CONS argv arg argv
SET "arg=!%4!"
IF NOT "!arg!"=="" CALL :CONS argv arg argv
SET "arg=!%3!"
IF NOT "!arg!"=="" CALL :CONS argv arg argv
SET "arg=!%2!"
IF NOT "!arg!"=="" CALL :CONS argv arg argv
CALL :SYMBOL_NEW argv_key_symbol argv_key
CALL :ENV_SET REPL_env argv_key_symbol argv

:REPL
    SET "_input="
    :: prompt the user and assign the user's input to _input.
    SET /p "_input=user> "
    :: If nothing is written, empty the input and reSET the error level
    IF  errorlevel 1 SET "_input=" & verify>nul
    :: Exit command used for testing purposes
    IF "!_input!"=="exit" EXIT

    CALL :REP _result _input REPL_env

    CALL :ECHO _result
GOTO :REPL

:REP
    CALL :READ REP_read %2
    CALL :EVAL REP_evaled REP_read %3
    CALL :PRINT %1 REP_evaled
EXIT /B 0

:READ
    CALL :READ_STR %1 %2
EXIT /B 0

:PRINT
    CALL :PR_STR %1 %2 TRUE
EXIT /B 0

:EVAL_AST
    CALL :LIST? EVAL_AST_is_list %2
    IF "!EVAL_AST_is_list!"=="!TRUE!" (
        CALL :LIST_MAP %1 %2 :EVAL %3
        EXIT /B 0
    )

    CALL :VECTOR? EVAL_AST_is_vector %2
    IF "!EVAL_AST_is_vector!"=="!TRUE!" (
        CALL :VECTOR_MAP %1 %2 :EVAL %3
        EXIT /B 0
    )

    CALL :HASHMAP? EVAL_AST_is_hashmap %2
    IF "!EVAL_AST_is_hashmap!"=="!TRUE!" (
        CALL :HASHMAP_MAP %1 %2 :EVAL %3
        EXIT /B 0
    )

    CALL :SYMBOL? EVAL_AST_is_symbol %2
    IF "!EVAL_AST_is_symbol!"=="!TRUE!" (
        CALL :SYMBOL_TO_STR EVAL_AST_symbol_str %2
        IF NOT "!EVAL_AST_symbol_str:~0,1!"=="!_colon!" (
            CALL :ENV_GET %1 %3 %2
            IF "!%1!"=="!NIL!" (
                CALL :SYMBOL_TO_STR EVAL_AST_symbol_str %2
                SET "EVAL_AST_error=Not defined: !EVAL_AST_symbol_str!"
                CALL :ERROR_NEW %1 EVAL_AST_error
            )
            EXIT /B 0
        )
    )

    SET "%1=!%2!"
EXIT /B 0

:EVAL_DEF_LIST
    SET /a "EVAL_DEF_LIST_recursion_count+=1"

    SET "EVAL_DEF_LIST_list%EVAL_DEF_LIST_recursion_count%=!%2!"
:_EVAL_DEF_LIST
    CALL :FIRST EVAL_DEF_LIST_key%EVAL_DEF_LIST_recursion_count% EVAL_DEF_LIST_list%EVAL_DEF_LIST_recursion_count%
    CALL :REST EVAL_DEF_LIST_list%EVAL_DEF_LIST_recursion_count% EVAL_DEF_LIST_list%EVAL_DEF_LIST_recursion_count%

    CALL :FIRST EVAL_DEF_LIST_value%EVAL_DEF_LIST_recursion_count% EVAL_DEF_LIST_list%EVAL_DEF_LIST_recursion_count%
    CALL :REST EVAL_DEF_LIST_list%EVAL_DEF_LIST_recursion_count% EVAL_DEF_LIST_list%EVAL_DEF_LIST_recursion_count%

    CALL :EVAL EVAL_DEF_LIST_evaluated_value%EVAL_DEF_LIST_recursion_count% EVAL_DEF_LIST_value%EVAL_DEF_LIST_recursion_count% %1

    CALL :ENV_SET %1 EVAL_DEF_LIST_key%EVAL_DEF_LIST_recursion_count% EVAL_DEF_LIST_evaluated_value%EVAL_DEF_LIST_recursion_count%

    IF NOT "!EVAL_DEF_LIST_list%EVAL_DEF_LIST_recursion_count%!"=="!EMPTY_LIST!" (
        GOTO :_EVAL_DEF_LIST
    )

    SET /a "EVAL_DEF_LIST_recursion_count-=1"
EXIT /B 0

:EVAL
    SET /a "EVAL_recursion_count+=1"
    SET "EVAL_ast%EVAL_recursion_count%=!%2!"
    SET "EVAL_env%EVAL_recursion_count%=!%3!"
:EVAL_RECUR
    CALL :LIST? EVAL_is_list%EVAL_recursion_count% EVAL_ast%EVAL_recursion_count%
    IF "!EVAL_is_list%EVAL_recursion_count%!"=="!TRUE!" (
        IF "!EVAL_ast%EVAL_recursion_count%!"=="!EMPTY_LIST!" (
            SET "%1=!EMPTY_LIST!"
            GOTO :EVAL_EXIT
        )

        CALL :FIRST EVAL_first_form%EVAL_recursion_count% EVAL_ast%EVAL_recursion_count%
        CALL :REST EVAL_rest%EVAL_recursion_count% EVAL_ast%EVAL_recursion_count%
        CALL :SYMBOL? EVAL_is_symbol%EVAL_recursion_count% EVAL_first_form%EVAL_recursion_count%
        IF "!EVAL_is_symbol%EVAL_recursion_count%!"=="!TRUE!" (
            CALL :SYMBOL_TO_STR EVAL_first_symbol_str%EVAL_recursion_count% EVAL_first_form%EVAL_recursion_count%
            IF "!EVAL_first_symbol_str%EVAL_recursion_count%!"=="fn*" (
                CALL :FIRST EVAL_params%EVAL_recursion_count% EVAL_rest%EVAL_recursion_count%
                CALL :REST EVAL_rest%EVAL_recursion_count% EVAL_rest%EVAL_recursion_count%
                CALL :FIRST EVAL_body%EVAL_recursion_count% EVAL_rest%EVAL_recursion_count%

                SET "EVAL_lambda_function%EVAL_recursion_count%=:MAL_LAMBDA"
                CALL :FUNCTION_NEW %1 EVAL_lambda_function%EVAL_recursion_count% EVAL_env%EVAL_recursion_count% EVAL_params%EVAL_recursion_count% EVAL_body%EVAL_recursion_count%
                GOTO :EVAL_EXIT
            )

            IF "!EVAL_first_symbol_str%EVAL_recursion_count%!"=="def^!" (
                CALL :FIRST EVAL_key%EVAL_recursion_count% EVAL_rest%EVAL_recursion_count%
                CALL :REST EVAL_rest%EVAL_recursion_count% EVAL_rest%EVAL_recursion_count%
                CALL :FIRST EVAL_value%EVAL_recursion_count% EVAL_rest%EVAL_recursion_count%
                CALL :EVAL EVAL_evaluated_value%EVAL_recursion_count% EVAL_value%EVAL_recursion_count% EVAL_env%EVAL_recursion_count%
                CALL :ENV_SET EVAL_env%EVAL_recursion_count% EVAL_key%EVAL_recursion_count% EVAL_evaluated_value%EVAL_recursion_count%
                SET "%1=!EVAL_evaluated_value%EVAL_recursion_count%!"
                GOTO :EVAL_EXIT
            )

            IF "!EVAL_first_symbol_str%EVAL_recursion_count%!"=="quote" (
                CALL :FIRST %1 EVAL_rest%EVAL_recursion_count%
                GOTO :EVAL_EXIT
            )

            IF "!EVAL_first_symbol_str%EVAL_recursion_count%!"=="quasiquote" (
                CALL :FIRST EVAL_expression%EVAL_recursion_count% EVAL_rest%EVAL_recursion_count%
                CALL :QUASIQUOTE EVAL_ast%EVAL_recursion_count% EVAL_expression%EVAL_recursion_count%
                GOTO :EVAL_RECUR
            )

            IF "!EVAL_first_symbol_str%EVAL_recursion_count%!"=="do" (
                CALL :REST EVAL_list%EVAL_recursion_count% EVAL_ast%EVAL_recursion_count%

                CALL :LIST_LAST EVAL_ast%EVAL_recursion_count% EVAL_list%EVAL_recursion_count%
                CALL :LIST_WITHOUT_LAST EVAL_list%EVAL_recursion_count% EVAL_list%EVAL_recursion_count%

                CALL :EVAL_AST EVAL_evaluated_list%EVAL_recursion_count% EVAL_list%EVAL_recursion_count% EVAL_env%EVAL_recursion_count%
                CALL :LIST_FIND EVAL_error%EVAL_recursion_count% EVAL_evaluated_list%EVAL_recursion_count% :ERROR?
                IF NOT "!EVAL_error%EVAL_recursion_count%!"=="!NIL!" (
                    SET "%1=!EVAL_error%EVAL_recursion_count%!"
                    GOTO :EVAL_EXIT
                )

                GOTO :EVAL_RECUR
            )

            IF "!EVAL_first_symbol_str%EVAL_recursion_count%!"=="if" (
                CALL :FIRST EVAL_predicate%EVAL_recursion_count% EVAL_rest%EVAL_recursion_count%
                CALL :REST EVAL_rest%EVAL_recursion_count% EVAL_rest%EVAL_recursion_count%
                CALL :FIRST EVAL_true_expression%EVAL_recursion_count% EVAL_rest%EVAL_recursion_count%

                CALL :EVAL EVAL_evaluated_predicate%EVAL_recursion_count% EVAL_predicate%EVAL_recursion_count% EVAL_env%EVAL_recursion_count%
                CALL :ERROR? EVAL_evaluated_predicate_is_error%EVAL_recursion_count% EVAL_evaluated_predicate%EVAL_recursion_count%
                IF "!EVAL_evaluated_predicate_is_error%EVAL_recursion_count%!"=="!TRUE!" (
                    SET "%1=!EVAL_evaluated_predicate%EVAL_recursion_count%!"
                    GOTO :EVAL_EXIT
                )

                SET "EVAL_is_falsey%EVAL_recursion_count%=!FALSE!"
                IF "!EVAL_evaluated_predicate%EVAL_recursion_count%!"=="!FALSE!" (
                    SET "EVAL_is_falsey%EVAL_recursion_count%=!TRUE!"
                )
                IF "!EVAL_evaluated_predicate%EVAL_recursion_count%!"=="!NIL!" (
                    SET "EVAL_is_falsey%EVAL_recursion_count%=!TRUE!"
                )

                IF "!EVAL_is_falsey%EVAL_recursion_count%!"=="!TRUE!" (
                    CALL :REST EVAL_rest%EVAL_recursion_count% EVAL_rest%EVAL_recursion_count%
                    IF NOT "!EVAL_rest%EVAL_recursion_count%!"=="!EMPTY_LIST!" (
                        CALL :FIRST EVAL_ast%EVAL_recursion_count% EVAL_rest%EVAL_recursion_count%
                        GOTO :EVAL_RECUR
                    ) ELSE (
                        SET "%1=!NIL!"
                        GOTO :EVAL_EXIT
                    )
                ) ELSE (
                    SET "EVAL_ast%EVAL_recursion_count%=!EVAL_true_expression%EVAL_recursion_count%!"
                    GOTO :EVAL_RECUR
                )
            )

            IF "!EVAL_first_symbol_str%EVAL_recursion_count%!"=="let*" (
                CALL :ENV_NEW EVAL_let_env%EVAL_recursion_count%
                CALL :ENV_SET_OUTER EVAL_let_env%EVAL_recursion_count% EVAL_env%EVAL_recursion_count%

                CALL :FIRST EVAL_def_list%EVAL_recursion_count% EVAL_rest%EVAL_recursion_count%

                CALL :VECTOR? EVAL_is_vector%EVAL_recursion_count% EVAL_def_list%EVAL_recursion_count%
                IF "!EVAL_is_vector%EVAL_recursion_count%!"=="!TRUE!" (
                    CALL :VECTOR_TO_LIST EVAL_def_list%EVAL_recursion_count% EVAL_def_list%EVAL_recursion_count%
                )

                CALL :EVAL_DEF_LIST EVAL_let_env%EVAL_recursion_count% EVAL_def_list%EVAL_recursion_count%

                CALL :REST EVAL_rest%EVAL_recursion_count% EVAL_rest%EVAL_recursion_count%
                CALL :FIRST EVAL_ast%EVAL_recursion_count% EVAL_rest%EVAL_recursion_count%
                SET "EVAL_env%EVAL_recursion_count%=!EVAL_let_env%EVAL_recursion_count%!"
                GOTO :EVAL_RECUR
            )
        )

        CALL :EVAL_AST EVAL_list%EVAL_recursion_count% EVAL_ast%EVAL_recursion_count% EVAL_env%EVAL_recursion_count%
        CALL :LIST_FIND EVAL_error%EVAL_recursion_count% EVAL_list%EVAL_recursion_count% :ERROR?
        IF NOT "!EVAL_error%EVAL_recursion_count%!"=="!NIL!" (
            SET "%1=!EVAL_error%EVAL_recursion_count%!"
            GOTO :EVAL_EXIT
        )

        CALL :FIRST EVAL_function%EVAL_recursion_count% EVAL_list%EVAL_recursion_count%
        CALL :REST EVAL_lambda_args%EVAL_recursion_count% EVAL_list%EVAL_recursion_count%

        CALL :FUNCTION_TO_STR EVAL_function_str%EVAL_recursion_count% EVAL_function%EVAL_recursion_count%
        IF "!EVAL_function_str%EVAL_recursion_count%!"==":MAL_LAMBDA" (
            CALL :FUNCTION_GET_PARAMS EVAL_lambda_params%EVAL_recursion_count% EVAL_function%EVAL_recursion_count%
            CALL :FUNCTION_GET_ENV EVAL_lambda_env_outer%EVAL_recursion_count% EVAL_function%EVAL_recursion_count%
            CALL :FUNCTION_GET_BODY EVAL_lambda_body%EVAL_recursion_count% EVAL_function%EVAL_recursion_count%

            CALL :ENV_NEW EVAL_lambda_env%EVAL_recursion_count%
            CALL :ENV_SET_OUTER EVAL_lambda_env%EVAL_recursion_count% EVAL_lambda_env_outer%EVAL_recursion_count%

            CALL :VECTOR? EVAL_lambda_params_is_vector%EVAL_recursion_count% EVAL_lambda_params%EVAL_recursion_count%
            IF "!EVAL_lambda_params_is_vector%EVAL_recursion_count%!"=="!TRUE!" (
                CALL :VECTOR_TO_LIST EVAL_lambda_params%EVAL_recursion_count% EVAL_lambda_params%EVAL_recursion_count%
            )

:EVAL_NEXT_ARG
            IF NOT "!EVAL_lambda_params%EVAL_recursion_count%!"=="!EMPTY_LIST!" (
                CALL :FIRST EVAL_lambda_param%EVAL_recursion_count% EVAL_lambda_params%EVAL_recursion_count%
                CALL :REST EVAL_lambda_params%EVAL_recursion_count% EVAL_lambda_params%EVAL_recursion_count%

                CALL :SYMBOL_TO_STR EVAL_lambda_param_str%EVAL_recursion_count% EVAL_lambda_param%EVAL_recursion_count%
                IF "!EVAL_lambda_param_str%EVAL_recursion_count%!"=="!_ampersand!" (
                    CALL :FIRST EVAL_lambda_param%EVAL_recursion_count% EVAL_lambda_params%EVAL_recursion_count%
                    CALL :ENV_SET EVAL_lambda_env%EVAL_recursion_count% EVAL_lambda_param%EVAL_recursion_count% EVAL_lambda_args%EVAL_recursion_count%

                ) ELSE (
                    CALL :FIRST EVAL_lambda_argument%EVAL_recursion_count% EVAL_lambda_args%EVAL_recursion_count%
                    CALL :REST EVAL_lambda_args%EVAL_recursion_count% EVAL_lambda_args%EVAL_recursion_count%
                    CALL :ENV_SET EVAL_lambda_env%EVAL_recursion_count% EVAL_lambda_param%EVAL_recursion_count% EVAL_lambda_argument%EVAL_recursion_count%
                    GOTO :EVAL_NEXT_ARG
                )
            )

            SET "EVAL_ast%EVAL_recursion_count%=!EVAL_lambda_body%EVAL_recursion_count%!"
            SET "EVAL_env%EVAL_recursion_count%=!EVAL_lambda_env%EVAL_recursion_count%!"
            GOTO :EVAL_RECUR
        ) ELSE (
            CALL :CALL_STACK_PUSH EVAL_lambda_args%EVAL_recursion_count%
            CALL !EVAL_function_str%EVAL_recursion_count%! EVAL_function%EVAL_recursion_count%
            CALL :CALL_STACK_POP %1
            GOTO :EVAL_EXIT
        )
    )

    CALL :EVAL_AST %1 EVAL_ast%EVAL_recursion_count% EVAL_env%EVAL_recursion_count%

:EVAL_EXIT
    SET /a "EVAL_recursion_count-=1"
EXIT /B 0

:CALL_STACK_PUSH
    SET /a "_call_stack_size+=1"
    SET "_call_stack_value!_call_stack_size!=!%1!"
EXIT /B 0

:CALL_STACK_POP
    SET "CALL_STACK_POP_ref=_call_stack_value!_call_stack_size!"
    SET "%1=!%CALL_STACK_POP_ref%!"
    SET /a "_call_stack_size-=1"
EXIT /B 0

:IS_PAIR
    CALL :LIST? IS_PAIR_is_list %2
    IF NOT "!%2!"=="!EMPTY_LIST!" (
        SET "%1=!IS_PAIR_is_list!"
        EXIT /B 0
    )
    SET "%1=!FALSE!"
EXIT /B 0

:QUASIQUOTE
    SET /A "QUASIQUOTE_recursion_count+=1"

    CALL :IS_PAIR QUASIQUOTE_is_pair%QUASIQUOTE_recursion_count% %2
    IF "!QUASIQUOTE_is_pair%QUASIQUOTE_recursion_count%!"=="!FALSE!" (
        SET "QUASIQUOTE_symbol_str%QUASIQUOTE_recursion_count%=quote"
        CALL :SYMBOL_NEW QUASIQUOTE_symbol%QUASIQUOTE_recursion_count% QUASIQUOTE_symbol_str%QUASIQUOTE_recursion_count%
        CALL :CONS QUASIQUOTE_result%QUASIQUOTE_recursion_count% %2 EMPTY_LIST
        CALL :CONS %1 QUASIQUOTE_symbol%QUASIQUOTE_recursion_count% QUASIQUOTE_result%QUASIQUOTE_recursion_count%
        GOTO :QUASIQUOTE_EXIT
    )

    CALL :FIRST QUASIQUOTE_first0%QUASIQUOTE_recursion_count% %2
    CALL :REST QUASIQUOTE_rest0%QUASIQUOTE_recursion_count% %2

    CALL :SYMBOL? QUASIQUOTE_is_symbol%QUASIQUOTE_recursion_count% QUASIQUOTE_first0%QUASIQUOTE_recursion_count%
    IF "!QUASIQUOTE_is_symbol%QUASIQUOTE_recursion_count%!"=="!TRUE!" (
        CALL :SYMBOL_TO_STR QUASIQUOTE_first_str%QUASIQUOTE_recursion_count% QUASIQUOTE_first0%QUASIQUOTE_recursion_count%
        IF "!QUASIQUOTE_first_str%QUASIQUOTE_recursion_count%!"=="unquote" (
            CALL :FIRST QUASIQUOTE_second0%QUASIQUOTE_recursion_count% QUASIQUOTE_rest0%QUASIQUOTE_recursion_count%
            SET "%1=!QUASIQUOTE_second0%QUASIQUOTE_recursion_count%!"
            GOTO :QUASIQUOTE_EXIT
        )
    )

    CALL :IS_PAIR QUASIQUOTE_is_pair%QUASIQUOTE_recursion_count% QUASIQUOTE_first0%QUASIQUOTE_recursion_count%
    IF "!QUASIQUOTE_is_pair%QUASIQUOTE_recursion_count%!"=="!TRUE!" (
        CALL :FIRST QUASIQUOTE_first1%QUASIQUOTE_recursion_count% QUASIQUOTE_first0%QUASIQUOTE_recursion_count%
        CALL :SYMBOL? QUASIQUOTE_is_symbol%QUASIQUOTE_recursion_count% QUASIQUOTE_first1%QUASIQUOTE_recursion_count%
        IF "!QUASIQUOTE_is_symbol%QUASIQUOTE_recursion_count%!"=="!TRUE!" (
            CALL :SYMBOL_TO_STR QUASIQUOTE_first_str%QUASIQUOTE_recursion_count% QUASIQUOTE_first1%QUASIQUOTE_recursion_count%
            IF "!QUASIQUOTE_first_str%QUASIQUOTE_recursion_count%!"=="splice-unquote" (
                SET "QUASIQUOTE_symbol_str%QUASIQUOTE_recursion_count%=concat"
                CALL :SYMBOL_NEW QUASIQUOTE_symbol%QUASIQUOTE_recursion_count% QUASIQUOTE_symbol_str%QUASIQUOTE_recursion_count%

                CALL :REST QUASIQUOTE_rest1%QUASIQUOTE_recursion_count% QUASIQUOTE_first0%QUASIQUOTE_recursion_count%
                CALL :FIRST QUASIQUOTE_second1%QUASIQUOTE_recursion_count% QUASIQUOTE_rest1%QUASIQUOTE_recursion_count%

                CALL :QUASIQUOTE QUASIQUOTE_result%QUASIQUOTE_recursion_count% QUASIQUOTE_rest0%QUASIQUOTE_recursion_count%

                CALL :CONS QUASIQUOTE_result%QUASIQUOTE_recursion_count% QUASIQUOTE_result%QUASIQUOTE_recursion_count% EMPTY_LIST
                CALL :CONS QUASIQUOTE_result%QUASIQUOTE_recursion_count% QUASIQUOTE_second1%QUASIQUOTE_recursion_count% QUASIQUOTE_result%QUASIQUOTE_recursion_count%
                CALL :CONS %1 QUASIQUOTE_symbol%QUASIQUOTE_recursion_count% QUASIQUOTE_result%QUASIQUOTE_recursion_count%

                GOTO :QUASIQUOTE_EXIT
            )
        )
    )

    SET "QUASIQUOTE_symbol_str%QUASIQUOTE_recursion_count%=cons"
    CALL :SYMBOL_NEW QUASIQUOTE_symbol%QUASIQUOTE_recursion_count% QUASIQUOTE_symbol_str%QUASIQUOTE_recursion_count%
    CALL :QUASIQUOTE QUASIQUOTE_result_first%QUASIQUOTE_recursion_count% QUASIQUOTE_first0%QUASIQUOTE_recursion_count%
    CALL :QUASIQUOTE QUASIQUOTE_result_rest%QUASIQUOTE_recursion_count% QUASIQUOTE_rest0%QUASIQUOTE_recursion_count%
    CALL :CONS QUASIQUOTE_result%QUASIQUOTE_recursion_count% QUASIQUOTE_result_rest%QUASIQUOTE_recursion_count% EMPTY_LIST
    CALL :CONS QUASIQUOTE_result%QUASIQUOTE_recursion_count% QUASIQUOTE_result_first%QUASIQUOTE_recursion_count% QUASIQUOTE_result%QUASIQUOTE_recursion_count%
    CALL :CONS %1 QUASIQUOTE_symbol%QUASIQUOTE_recursion_count% QUASIQUOTE_result%QUASIQUOTE_recursion_count%

:QUASIQUOTE_EXIT
    SET /A "QUASIQUOTE_recursion_count-=1"
EXIT /B 0
